//#############################################################################################
//# Acapella Script and proc edures Collection: A collection of Acapella based scripts
//# and libraries.
//#
//# Please acknowledge the author(s)/contributor(s) for making use of these scripts and library.
//# Authors:
//#   * Ghislain M.C. Bonamy
//#   * Genomics Institute of the Novartis Research Fundation (GNF), San Diego, CA 92122
//#   * www.gnf.org
//#
//# You can obtain the latest version of this software at: http://code.google.com/p/operahci/
//#
//# This program is free software; you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation; either version 2 of the License, or
//# (at your option) any later version.
//#
//# This program is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with this program; if not, write to the Free Software
//# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//# or go to: http://www.apache.org/licenses/
//#############################################################################################

//*********************************************************************************************
//*
//* This script is used to measure Nuclear translocation. Several nuclear
//* translocation models are provided. Typically the pearsonR value between the
//* nculear channel and the "marker" channel provides the best proxy to nuclear
//* translocation.
//*
//*********************************************************************************************

Proc getChanInfo(memblock chanInfo out){

	input(name, "Exp1Cam1", "NucChannelName", type="String", description="Channel containing the Nuclear stain. Allowed values: \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\".")
	input(desc, "Hoechst", "Nuclear StainDescription", type="String", description="Description of the Nuclear channel (ex. Hoechst, MGD...).")
	input(minIntensity, 150, "Min Nuclear Channel Intensity", type="i",  description="Minimum intensity for the Nuclear channel images to be considered as positive. Allowed range: 0..1000.")
	push(chanPurpose,"nucDetection")
	push(chanNames,name)
	push(chanDesc,desc)
	push(chanMin,minIntensity)
	push(chanCutOff,0)
	push(pearsonRCutOffVec,0.0)

	input(Name, "Exp1Cam2", "CytoplasmicChannelName", type="String", description="Channel containing the fluorescence from the Cytoplasmic stain. Can be same as Nuclear channel. Allowed values: \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\",\"NA\".")
	input(desc, "MGD", "Cytoplasmic StainDescription", type="String", description="Description of the Cytoplasmic stain.")
	if(desc=="NA" || Name=="NA")
		set(desc="NA",Name="NA")
	end()
	input(cutOff, 150, "Min Cytoplasmic Channel Intensity", type="i",  description="Minimum intensity for the Cytoplasmic channel images to be considered as positive. Allowed range: 1..1000, step 0.1.")
	if(cutOff<1)
		Error("The cutt-off must be >= to 1")
	end()
	push(chanPurpose,"cytoDetection")
	push(chanNames,Name)
	push(chanDesc,desc)
	push(chanMin,0)
	push(chanCutOff,cutOff)
	push(pearsonRCutOffVec,0.0)

	input(Name, "Exp1Cam1", "Marker1ChannelName", type="String", description="Channel containing the fluorescence from the first marker. Allowed values: \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\",.")
	input(desc, "GFP", "Marker1Description", type="String", description="Description of the first marker (ex. GFP).")
	input(cutOff, 150, "Marker1 Positive CuttOff", type="i",  description="Cutt-off value used to define cells expressing the first marker. Allowed range: 1..1000, step 0.1.")
	input(pearsonRCutOff, 0, "Nuclear Translocation CutOff", type="d",  description="CutOff for PearsonR to classify cells as translocated or not. Use 0 if you do not wish to split cells in translocated vs. non translocated. Allowed range: -1..1, step 0.01.")
	if(pearsonRCutOff<-1||pearsonRCutOff>1)
		Error("The cutt-off must be >= to 1")
	end()
	push(chanPurpose,"marker")
	push(chanNames,Name)
	push(chanDesc,desc)
	push(chanMin,0)
	push(chanCutOff,cutOff)
	push(pearsonRCutOffVec,pearsonRCutOff)


	set(chanInfo=tbl(name=chanNames, desc=chanDesc,min=chanMin,purpose=chanPurpose, cutOff=chanCutOff, pearsonRCutOff=pearsonRCutOffVec))

}


Proc paramInit(memblock param out){

	input(showIllustrations, false, "showIllustrations", type="b", description="Indicate whether or not you want to see the illustrations for the objects detected. Used in combination with fieldToAnalyze. This option is deactivated on the RMCA.")
	EnvInfo()
	Set(showIllustrations=showIllustrations && env_interactive && env_supports_graphview && env_supports_htmlview && env_supports_imageview && env_supports_tableview)
	input(fieldSelected, 1, "fieldToAnalyze", type="i", description="If show illustration is selected, only analyze the selected field. use \"0\" to analyze every fields.")
	input(getSingleCellFeatures, false, "Save Single-Cell Features", type="b", description="Indicate whether or not you want to save the single cell features to a file.")
	input(getROI, false, "Save ROI", type="b", description="Indicate whether or not you want to save the Nuclear and cellular outlines to a file.")
	input(OutputStatType, "Median", "Well Aggregation", type="String", description="Select how the multiple fields should be agregated accross Channles. Allowed values: \"Mean\", \"Median\",\"Min\",\"Max\",\"Sum\",\"AllValues\".")

	input(cutOffType, "threshold", "Cut-Off type", type="string", description="Enter the type of cutt-off you wish to use. Each of these methods corresponds to: \"threshold: intensity of the cell to be considered positive\" \"folds: number of fold above the background to be considered as positive\", \" stddev: number of bckground standard deviation to be considered as positive\". Allowed values: \"threshold\", \"folds\", \"stddev\".")
	if(cutOffType!="threshold"&&cutOffType!="folds"&&cutOffType!="stddev")
		error("The Cut-Off type must be either  \"threshold\", \"folds\" or \"stddev\"")
	end()
	Pack(param,*)
	keep(param)
}

Proc imageAnalysis(memblock images in, memblock param in, container imageData out){

	input(distanceTrimed,1,"Distance to Trim:Nuclear Translocation","i","Distance in pixels to remove from the nucleus and from the cytoplasm around the nuclear membrane.")
	input(rimSize,3,"Donnut Size:Nuclear Translocation","i","Distance size in pixel of the donut around the nucleus. Default=3")
	input(useDonutModel, true, "Use Donut Model:Nuclear Translocation", type="b", description="Assumes a donut around the nucleus to emulate the cytoplasm, if no cytoplasmic channel is provided, this method will be used.")
	input(NucleiNormalization,2.5,"NucleiNormalization:Nuclear Translocation","d","Normalize the nuclei population so that outliers are removed.Nuclei with properties that are more than this number of standardaviation away from the population mean are removed.")

	Unpack(param)
	//set(cytoChanNum=-1)
	//if(findElem("cytoDetection",chanInfo.purpose).pos>=0)
		set(cytoChanNum=chanInfo.number[findElem("cytoDetection",chanInfo.purpose).pos])
	//end()
	set(nucChanNum=chanInfo.number[findElem("nucDetection",chanInfo.purpose).pos])
	set(nucChanMin=chanInfo.min[findElem("nucDetection",chanInfo.purpose).pos])
	set(markerChanNum=chanInfo.number[findElem("marker",chanInfo.purpose).pos])
	set(imageData=cnt())
	if(images[nucChanNum].image.max>nucChanMin)
		bckGndSubstraction(-1,images=images)

		set(minNucIntensity=stdDevToSubstract*bckGndObjects["Body_"&images[nucChanNum].desc&"_StdDevIntensity"].mean+1)

		set(nucImage=images[nucChanNum].image)
		Nuclei_Detection(nucImage)

		if(cytoChanNum>=0)
			set(minCytoIntensity=stdDevToSubstract*bckGndObjects["Body_"&images[cytoChanNum].desc&"_StdDevIntensity"].mean)
			convert(bpp=1,image=images[cytoChanNum].image)
			Cytoplasm_Detection_Select(reference=image)
			CalcIntensity(image=images[cytoChanNum].image,objects=WholeCells)
			ObjectFilter(intensity>minCytoIntensity,objects=objects|WholeCells=objects)
		end()
		if(useDonutModel || cytoChanNum==-1)
			Set(objects=nuclei)
			Set(NumberOfOuterZones=distanceTrimed+rimSize)
			if(defined("wholeCells"))
				calczone(NumberOfOuterZones, zonetype="equidistant",Stencil=Wholecells.Body)
			else()
				calczone(NumberOfOuterZones, zonetype="equidistant")
			end()
			zonemask(distanceTrimed, oo)
			renameattr(innerRegion=zonemask)
			zonemask(0, -1*rimSize)
			renameattr(outerRegion=zonemask)
			Set(temp=objects)
			Stencil2Objects(objects.outerRegion)
			FillObjects()
			SetAttr(centers,temp.innerRegion)
			CalcBorder(centers)
			SetAttr(cytoplasm,temp.outerRegion)
			CalcBorder(cytoplasm)
			Delete(Temp)
			if(showIllustrations)
				ImageView(objects.centers_border,label="Centers-"&images[nucChanNum].desc, title="Area used for the centers for channel "&images[nucChanNum].desc &" ajust per \"Distance to Trim\". Cell count="&objects.Count, image=images[nucChanNum].image,  gamma=1)
				if(cytoChanNum==-1)
					set(chan=nucChanNum)
				else()
					set(chan=cytoChanNum)
				end()
				ImageView(objects.cytoplasm_border,label="Donut-"&images[chan].desc, title="Ring Borders for channel "&images[chan].desc &"adjust per \"Donnut Size\". Cell count="&objects.Count, image=images[chan].image,  gamma=1)
			end()
			rename(wholeCells=objects)
		end()
	//Filtering of nuclei. Then select corresponding cells
		ObjectFilter(intensity>minNucIntensity,objects=nuclei)
		normalizeObjects(NucleiNormalization,image=nucImage,keepCaluclatedAttributes=true)
		if(showIllustrations)
			ImageView(objects.border.mask,label="Nuclei", title="Nuclei Detected. Cell count="&objects.Count,image=nucImage,  gamma=2)
		end()
		Stencil2Objects(objects.body)
		CalcMassCentre()
		rename(nuclei=objects,objects=wholeCells)
		CalcIntensity(image=Nuclei.MassCentre.mask.image)
		ObjectFilter(intensity>0)
		DeleteAttr(intensity)
		CalcStat("mean",image=images[markerChanNum].image,Stencil=Body, AttrName=images[markerChanNum].desc&"_BodyIntensity")
		CalcStat("mean",image=images[markerChanNum].image,Stencil=Centers,AttrName=images[markerChanNum].desc&"_NuclearIntensity")
		CalcStat("mean",image=images[markerChanNum].image,Stencil=Cytoplasm,AttrName=images[markerChanNum].desc&"_CytoplasmicIntensity")
		SetAttr(images[markerChanNum].desc&"_Ratio_Nuc_To_CytoIntensity",objects[images[markerChanNum].desc&"_NuclearIntensity"]/objects[images[markerChanNum].desc&"_CytoplasmicIntensity"])

		MBF_PearsonsCoefficient(images[markerChanNum].image,images[nucChanNum].image,objects|temp=objects)
		setAttr(images[markerChanNum].desc&"_PearsonR",temp.PearsonsR, Objects=Objects)
		delete(temp)

		CalcFeatures(images=vec())
		set(WholeCells=objects)

		if(cutOffType=="folds")
			set(formula=(images[markerChanNum].cutoff-1)&"*"&bckGndObjects["Body_"&images[markerChanNum].desc&"_MeanIntensity"].mean)
		else()if(cutOffType=="stddev")
			set(formula=images[markerChanNum].cutoff&"*"&bckGndObjects["Body_"&images[markerChanNum].desc&"_StdDevIntensity"].mean)
		else()
			set(formula=images[markerChanNum].cutoff-images[markerChanNum].bckGndSubstracted)
		end()end()

		SplitMyObjects(images[markerChanNum].desc&"_CytoplasmicIntensity>"&formula,objects=objects)
		Set(temp=objects)
		SplitMyObjects(images[markerChanNum].desc&"_NuclearIntensity>"&formula,objects=Remainder)
		AddObjects(temp)
		delete(temp)
		if(showIllustrations)
			if(cutOffType=="folds")
				set(cutOff=(images[markerChanNum].cutoff-1)*bckGndObjects["Body_"&images[markerChanNum].desc&"_MeanIntensity"].mean)
			else()if(cutOffType=="stddev")
				set(cutOff=images[markerChanNum].cutoff*bckGndObjects["Body_"&images[markerChanNum].desc&"_StdDevIntensity"].mean)
			else()
				set(cutOff=images[markerChanNum].cutoff-images[markerChanNum].bckGndSubstracted)
			end()
			end()

			GraphView(wholeCells.[images[markerChanNum].desc&"_CytoplasmicIntensity"], label=images[markerChanNum].desc&"-Intensity",title="Intensity for channel "&images[markerChanNum].desc&". CalculatedCutOff="&round(cutOff*100)/100, presto_options="graph.yaxis.title Intensity, set[0].line.color black")
			GraphView(wholeCells.[images[markerChanNum].desc&"_NuclearIntensity"], label=images[markerChanNum].desc&"-Intensity", append=true, presto_options="graph.yaxis.title Intensity, set[0].line.color green")
			GraphView(tabulate(cutOff,wholeCells.count).result, label=images[markerChanNum].desc&"-Intensity", append=true, presto_options="set[0].line.color Red")
			ImageView(objects.cytoplasm_border,label=images[markerChanNum].desc&"-Pos", title="Cells which are fositive for "&images[markerChanNum].desc&". Cell count="&objects.Count, image=images[markerChanNum].image,  gamma=2)
		end()
		set(objectSet=cnt(images[markerChanNum].desc&"_Positive"=objects))
		rename(positiveCells=objects)

		set(cutOff=images[markerChanNum].pearsonRCutOff)
		if(cutOff != 0)
			ObjectFilter(images[markerChanNum].desc&"_PearsonR>cutOff", objects=wholeCells)
			if(showIllustrations)
				ObjectFilter(images[markerChanNum].desc&"_PearsonR>cutOff", objects=wholeCells)
				GraphView(wholeCells.[images[markerChanNum].desc&"_PearsonR"], label=images[markerChanNum].desc&"-PearsonR",title="PearsonR for "&images[markerChanNum].desc&". CutOff="&round(cutOff*100)/100, presto_options="graph.yaxis.title Intensity, set[0].line.color black")
				GraphView(tabulate(cutOff,wholeCells.count).result, label=images[markerChanNum].desc&"-PearsonR", append=true, presto_options="set[0].line.color Red")
				ImageView(objects.cytoplasm_border,label=images[markerChanNum].desc&"Translocated", title="Cells which exibit translocation for "&images[markerChanNum].desc&". Cell count="&objects.Count, image=images[markerChanNum].image,  gamma=2)
				ImageView(remainder.cytoplasm_border,label=images[markerChanNum].desc&"NotTranslocated", title="Cells which do not exibit translocation for "&images[markerChanNum].desc&". Cell count="&objects.Count, image=images[markerChanNum].image,  gamma=2)
			end()

			set(objectSet["FullSet_Translocated"]=objects)
			set(objectSet["FullSet_NotTranslocated"]=remainder)

			ObjectFilter(images[markerChanNum].desc&"_PearsonR>cutOff", objects=positiveCells)
			if(showIllustrations)
				GraphView(positiveCells.[images[markerChanNum].desc&"_PearsonR"], label=images[markerChanNum].desc&"-PositivePearsonR",title="PearsonR for "&images[markerChanNum].desc&" positive cells. CutOff="&round(cutOff*100)/100, presto_options="graph.yaxis.title Intensity, set[0].line.color black")
				GraphView(tabulate(cutOff,positiveCells.count).result, label=images[markerChanNum].desc&"-PositivePearsonR", append=true, presto_options="set[0].line.color Red")
				ImageView(objects.cytoplasm_border,label=images[markerChanNum].desc&"PosTranslocated", title="Cells which exibit translocation and are fositive for "&images[markerChanNum].desc&". Cell count="&objects.Count, image=images[markerChanNum].image,  gamma=2)
				ImageView(remainder.cytoplasm_border,label=images[markerChanNum].desc&"PosTranslocated", title="Cells which do not exibit translocation and are fositive for "&images[markerChanNum].desc&". Cell count="&objects.Count, image=images[markerChanNum].image,  gamma=2)
			end()

			set(objectSet[images[markerChanNum].desc&"_PositiveTranslocated"]=objects)
			set(objectSet[images[markerChanNum].desc&"_PositiveNotTranslocated"]=remainder)
		end()

		assembleCompositObject(objectSet,objects=wholeCells|wholeCells=compositObject)

		CalcFeatures(objects=nuclei,images=vec(images[nucChanNum]),parentNames=("WholeCells"),parentObjects=cnt("WholeCells"=WholeCells)|Nuclei=Objects)
		keep(bckGndObjects,Nuclei,WholeCells)//,PositiveCells)
		pack(imageData,*)
	end()
}

Proc Analysis(memblock images in,memblock param in, memblock sourceDataProp inout, container data out){

	set(wholeWellData=cnt())
	set(numFieldsInFocus=0)
	Set(FeaturesTable=Tbl(),ROITable=Tbl())
	if(images.length>0)
	foreach(0..images.length-1, "field")
	foreach(0..images[field].length-1, "stack")
		if(images[field][stack].length==0)
			continue()
		end() 

		imageAnalysis(images[field][stack],param)

		if(imageData.length>0)
			set(numFieldsInFocus=numFieldsInFocus+1)
			if(param.getROI)
				if(defined("imageData.Nuclei"))
					getROITable(imageData.Nuclei,ObjectType="Nuclei")
				end()
				if(defined("imageData.WholeCells"))
					getROITable(imageData.WholeCells,ObjectType="WholeCells")
				end()
			end()
			if(param.getSingleCellFeatures)
				Foreach(imageData.keys,"keyName")
					Set(objects=ImageData[keyName])
						if(objects.class=="objectlist"||objects.class=="compositObjectlist")
							try() //Skip objects that do not have a real setncil stencil and for which a center of mass can be determined.
								getFeaturesTable(objects,ObjectType=keyname)
							Catch_Error()
							end()
						end()
				end()
			end()

			combineMemBlocks(wholeWellData, imageData,DeleteGeometry=true,KeepAutoRecalc=false)
			rename(wholeWellData=newData)
		end()
		delete(imageData)
	end()
	end()
	end()

	Set(singleCellData=Cnt())
	if(param.getSingleCellFeatures)
		Set(singleCellData.Features=FeaturesTable)
	end()
	if(param.getROI)
		Set(singleCellData.ROI=ROITable)
	end()
	set(wholeWellData.numFieldsInFocus=numFieldsInFocus)
	pack(data,wholeWellData,singleCellData)
}

//#######################
// Program Start
//#######################
getChanInfo()
ParamInit()
ImagesInit()
chanAttrib()
set(param.chanInfo=chanInfo)
if(param.showIllustrations&&param.fieldSelected!=0)
	set(param.fieldSelected=iif(param.fieldSelected<1,1,param.fieldSelected))
	set(param.fieldSelected=iif(param.fieldSelected>images.length,images.length,param.fieldSelected))
	set(Images=vec(images[param.fieldSelected-1]))
end()

Analysis()
writeChannelMapping(images, sourcedataprop.fileDir,sourcedataprop.WellIndex)
dataOutput(data,sourcedataprop,param.OutputStatType)