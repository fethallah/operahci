//#############################################################################################
//# Acapella Script and proc edures Collection: A collection of Acapella based scripts
//# and libraries.
//#
//# Please acknowledge the author(s)/contributor(s) for making use of these scripts and library.
//# Authors:
//#   * Ghislain M.C. Bonamy
//#   * Genomics Institute of the Novartis Research Fundation (GNF), San Diego, CA 92122
//#   * www.gnf.org
//#
//# You can obtain the latest version of this software at: http://code.google.com/p/operahci/
//#
//# This program is free software; you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation; either version 2 of the License, or
//# (at your option) any later version.
//#
//# This program is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with this program; if not, write to the Free Software
//# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//# or go to: http://www.apache.org/licenses/
//#############################################################################################

//*********************************************************************************************
//*
//* This script is used to collect basic information about the images collected
//*
//*********************************************************************************************
Proc getChanInfo(memblock chanInfo out){

	input(name, "NA", "Channel1 Name", type="String", description="1st Channel Name. Allowed values: \"NA\", \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\".")
	input(desc, "NA", "Channel1 Description", type="String", description="Description of the 1st Channel (ex. GFP, Hoechst, MGD...).")
	push(chanNames,name)
	push(chanDesc,desc)
	push(chanPurpose,"marker")

	input(name, "NA", "Channel2 Name", type="String", description="2snd Channel Name. Allowed values: \"NA\", \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\".")
	input(desc, "NA", "Channel2 Description", type="String", description="Description of the 2snd Channel (ex. GFP, Hoechst, MGD...).")
	push(chanNames,name)
	push(chanDesc,desc)
	push(chanPurpose,"marker")

	input(name, "NA", "Channel3 Name", type="String", description="3rd Channel Name. Allowed values: \"NA\", \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\".")
	input(desc, "NA", "Channel3 Description", type="String", description="Description of the 3rd Channel (ex. GFP, Hoechst, MGD...).")
	push(chanNames,name)
	push(chanDesc,desc)
	push(chanPurpose,"marker")

	input(name, "NA", "Channel4 Name", type="String", description="4th Channel Name. Allowed values: \"NA\", \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\".")
	input(desc, "NA", "Channel4 Description", type="String", description="Description of the 4th Channel (ex. GFP, Hoechst, MGD...).")
	push(chanNames,name)
	push(chanDesc,desc)
	push(chanPurpose,"marker")

	input(name, "NA", "Channel5 Name", type="String", description="5th Channel Name. Allowed values: \"NA\", \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\".")
	input(desc, "NA", "Channel5 Description", type="String", description="Description of the 5th Channel (ex. GFP, Hoechst, MGD...).")
	push(chanNames,name)
	push(chanDesc,desc)
	push(chanPurpose,"marker")

	input(name, "NA", "Channel6 Name", type="String", description="6th Channel Name. Allowed values: \"NA\", \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\".")
	input(desc, "NA", "Channel6 Description", type="String", description="Description of the 6th Channel (ex. GFP, Hoechst, MGD...).")
	push(chanNames,name)
	push(chanDesc,desc)
	push(chanPurpose,"marker")

	set(chanInfo=tbl(name=chanNames, desc=chanDesc, purpose=chanPurpose))
}


Proc paramInit(memblock param out){

	input(SubstractBackground, false, "Subtract Background", type="b", description="Indicate whether you want to detect and subtract the background.")
	input(minObjectSize,5,"Minimum Object Size",Type="d", description="Minimum size of the object to be considered as part of the pixels above background. Help remove small artifacts. modify qith \"Pizel Above Background\" preview. Allowed range: 0..1000, step 1.")
	input(OutputStatType, "Median", "Well Aggregation", type="String", description="Select how the multiple fields should be aggregated across Channels. Allowed values: \"Mean\", \"Median\",\"Min\",\"Max\",\"Sum\",\"AllValues\".")
	input(ZStackProjectionType, "NA", "Z-Stack Projection", type="String", description="Select what type of Z-projection you wish to use. \"NA\" indicates that you do not wish to project your z-stack, but use each section as an independent measurement. Allowed values: \"NA\", \"Add\", \"Average\", \"Max\", \"Min\".")
	input(showIllustrations, false, "Show Illustrations", type="b", description="Indicate if you want to see the illustration for the objects detected.")
	input(fieldSelected, 1, "Field To Analyze", type="i", description="If show illustration is selected, only analyze the selected field. use \"0\" to analyze every fields.")

	Pack(param,*)
	keep(param)
}

Proc imageAnalysis(memblock images in, memblock param in, container imageData out){
	Unpack(param)
	set(imageData=cnt())
	if(SubstractBackground)
		bckGndSubstraction(-1,images=images)
		set(ImageData.bckGndObjects=bckGndObjects)
	end()
	Set(WholeWell=cnt())
	Blank(images[0].image.width,images[0].image.height,1)
	Mask(0)
	Mask2Stencil()
	Stencil2Objects()
	Rename(WholeWell=objects)
	If(SubstractBackground)
		Foreach(0..images.length-1)
			set(image=images[i].image)
				set(image=image/image*image)
				mean(4)
				Mask(1)
				Mask2Stencil(Neighbourhood=8)
				Stencil2Objects()
				Mask2Stencil(objects.border.mask, Neighbourhood=8)
				Stencil2Objects()
				FillObjects()
				CalcArea()
				ObjectFilter(area<minObjectSize)
				Set(mask=objects.body.mask.image+mask.image)
				Mask(1,image=mask)
				//Erosion(1,refill=true, image=mask|mask=image)
				Mask2Stencil(Neighbourhood=8)
				Stencil2Objects()
				CalcArea()
				ObjectFilter(area>minObjectSize)
				Mask2Stencil(objects.body.mask,method= "One large object", Neighbourhood=8)
				Stencil2Objects()
				CalcArea()
				delete(mask,stencil,image)
				Set(image=images[i].image)
				if(showIllustrations)
					imageview(objects.border,label ="PixelsAboveBckGnd-"&Images[i].desc,image=image,gamma=2)
				end()
				getFeatures(objects,vec(images[i]))
				Set(WholeWell[images[i].desc&"_AreaAboveBackground"]=objects.area)
				Set(WholeWell[images[i].desc&"_AreaBellowBackground"]=image.width*image.height-objects.area)
				Set(WholeWell[images[i].desc&"_AreaFractionAboveBackground"]=objects.area/(image.width*image.height))
				Foreach(objects.keys,"keyName")
					if(at("Body_",keyName,1)>0)
						set(newKeyName=RegexReplace(keyName,"Body_","").text)
						set(Val=objects[keyName])
						if(Val.class=="vector" && Val.class!="intervalvector" && Val.class!="indexvector" && (Val.elemtype<8||Val.elemtype==13))
							Set(WholeWell[newKeyName]=Val)
						end()
					end()
				end()
		end()
	else()
		getFeatures(WholeWell,images)
		Foreach(objects.keys,"keyName")
			if(at("Body_",keyName,1)>0)
				set(newKeyName=RegexReplace(keyName,"Body_","").text)
				set(Val=objects[keyName])
				if(Val.class=="vector" && Val.class!="intervalvector" && Val.class!="indexvector" && (Val.elemtype<8||Val.elemtype==13))
					Set(WholeWell[newKeyName]=Val)
				end()
			end()
		end()
	end()
	set(imageData.WholeWell=WholeWell)
}
Proc Analysis(memblock images in,memblock param in, memblock sourceDataProp inout, container data out){

	set(data=create("container").container)
	set(numFieldsInFocus=0)
	if(images.length>0)
	foreach(0..images.length-1, "field")
	foreach(0..images[field].length-1, "stack")
		imageAnalysis(images[field][stack],param)
		if(imageData.length>0)
			set(numFieldsInFocus=numFieldsInFocus+1)
			combineMemBlocks(data, imageData,DeleteGeometry=true,KeepAutoRecalc=false)
			rename(data=newData)
		end()
		delete(imageData)
	end()
	end()
	end()
	set(data.numFieldsInFocus=numFieldsInFocus)
}

//#######################
// Program Start
//#######################
getChanInfo()
ParamInit()
ImagesInit()
chanAttrib()
set(param.chanInfo=chanInfo)
if(param.ZStackProjectionType!="NA")
	ProjectsStacks(method=param.ZStackProjectionType)
end()
if(param.showIllustrations&&param.fieldSelected!=0)
	set(param.fieldSelected=iif(param.fieldSelected<1,1,param.fieldSelected))
	set(param.fieldSelected=iif(param.fieldSelected>images.length,images.length,param.fieldSelected))
	set(Images=vec(images[param.fieldSelected-1]))
end()

Analysis()
writeChannelMapping(images, sourcedataprop.fileDir,sourcedataprop.WellIndex)
dataOutput(data,sourcedataprop,param.OutputStatType)