//#############################################################################################
//# Acapella Script and procedures Collection: A collection of Acapella based scripts
//# and libraries.
//#
//# Please acknowledge the author(s)/contributor(s) for making use of these scripts and library.
//# Authors:
//#   * Ghislain M.C. Bonamy
//#   * Genomics Institute of the Novartis Research Foundation (GNF), San Diego, CA 92122
//#   * www.gnf.org
//#
//# You can obtain the latest version of this software at: http://code.google.com/p/operahci/
//#
//# This program is free software; you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation; either version 2 of the License, or
//# (at your option) any later version.
//#
//# This program is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with this program; if not, write to the Free Software
//# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//# or go to: http://www.apache.org/licenses/
//#############################################################################################

//*********************************************************************************************
//*
//* This  Script extract multiple cellular information and features.
//*
//*********************************************************************************************

proc getChanInfo(
	memblock chanInfo out
)
{
	input(name, "Exp1Cam1", "NucChannelName", type="String", description="Channel containing the Nuclear stain. Allowed values: \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\".")
	input(desc, "Hoechst", "Nuclear StainDescription", type="String", description="Description of the Nuclear channel (ex. Hoechst, MGD...).")
	input(minIntensity, 150, "Min Nuclear Channel Intensity", type="i",  description="Minimum intensity for the Nuclear channel images to be considered as positive.Allowed range: 0..1000, step 1.")
	push(chanPurpose,"nucDetection")
	push(chanNames,name)
	push(chanDesc,desc)
	push(chanMin,minIntensity)
	push(chanCutOff,0)

	input(Name, "NA", "CytoplasmicChannelName", type="String", description="Channel containing the fluorescence from the cytoplasmic stain. Can be same as Nuclear channel. Allowed values: \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\",\"NA\".")
	input(desc, "MGD", "Cytoplasmic StainDescription", type="String", description="Description of the Cytoplasmic stain.")
	input(cutOff, 150, "Min Cytoplasmic Channel Intensity", type="d",  description="Minimum intensity for the Cytoplasmic channel images to be considered as positive. Allowed range: 1..1000, step 1.")
	if(cutOff<1)
		Error("The cutt-off must be >= to 1")
	end()
	push(chanPurpose,"cytoDetection")
	push(chanNames,Name)
	push(chanDesc,desc)
	push(chanMin,0)
	push(chanCutOff,cutOff)

	input(Name, "NA", "MembraneChannelName", type="String", description="Channel containing the fluorescence from the membrane stain. This is only useful if selecting cytoplasmic algorithm F. Can be same as Cytoplasmic channel. Allowed values: \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\",\"NA\".")
	input(desc, "WGA", "Membrane StainDescription", type="String", description="Description of the Membrane stain.")
	push(chanPurpose,"membraneDetection")
	push(chanNames,Name)
	push(chanDesc,desc)
	push(chanMin,0)
	push(chanCutOff,1)


	input(Name, "NA", "SpotChannelName", type="String", description="Channel containing the fluorescence from the spot stain. Can be same as Cytoplasmic channel. Allowed values: \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\",\"NA\".")
	input(desc, "LisoTracker", "Spot StainDescription", type="String", description="Description of the spot-like stain.")
	push(chanPurpose,"spotsDetection")
	input(cutOff, 150, "Spots Positive cutOff", type="i",  description="Cut-off value to use to define positive spots. Allowed range: 1..5000, step 1.0.")
	Set(cutOff=iif(cutOff<1,1,cutOff))
	push(chanNames,Name)
	push(chanDesc,desc)
	push(chanMin,0)
	push(chanCutOff,1)

	input(Name, "NA", "Marker1ChannelName", type="String", description="Channel containing the fluorescence from the first marker. Allowed values: \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\",\"NA\".")
	input(desc, "GFP", "Marker1Description", type="String", description="Description of the first marker (ex. GFP). Do not use space or any other special characters.")
	if(desc=="NA" || Name=="NA")
		set(desc="NA",Name="NA")
	end()
	input(cutOff, 150, "Marker1 Positive cutOff", type="i",  description="Cut-off value to use to define. Allowed range: 1..5000, step 1.0.")
	Set(cutOff=iif(cutOff<1,1,cutOff))
	push(chanPurpose,"marker")
	push(chanNames,Name)
	push(chanDesc,desc)
	push(chanMin,0)
	push(chanCutOff,cutOff)

	input(Name, "NA", "Marker2ChannelName", type="String", description="Channel containing the fluorescence from the second marker.Allowed values: \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\",\"NA\".")
	input(desc, "RFP", "Marker2Description", type="String", description="Description of the second marker (ex. RFP) or NA. Do not use space or any other special characters.")
	if(desc=="NA" || Name=="NA")
		set(desc="NA",Name="NA")
	end()
	input(cutOff, 150, "Marker2 Positive cutOff", type="i",  description="Cut-off value to use to define. Allowed range: 1..5000, step 1.0.")
	Set(cutOff=iif(cutOff<1,1,cutOff))
	push(chanPurpose,"marker")
	push(chanNames,Name)
	push(chanDesc,desc)
	push(chanMin,0)
	push(chanCutOff,cutOff)

	input(Name, "NA", "Marker3ChannelName", type="String", description="Channel containing the fluorescence from the second marker.Allowed values: \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\",\"NA\".")
	input(desc, "MitoTracker", "Marker3Description", type="String", description="Description of the second marker (ex. RFP) or NA. Do not use space or any other special characters.")
	if(desc=="NA" || Name=="NA")
		set(desc="NA",Name="NA")
	end()
	input(cutOff, 150, "Marker3 Positive cutOff", type="i",  description="Cut-off value to use to define. Allowed range: 1..5000, step 1.0.")
	Set(cutOff=iif(cutOff<1,1,cutOff))
	push(chanPurpose,"marker")
	push(chanNames,Name)
	push(chanDesc,desc)
	push(chanMin,0)
	push(chanCutOff,cutOff)

	input(Name, "NA", "Marker4ChannelName", type="String", description="Channel containing the fluorescence from the second marker.Allowed values: \"Exp1Cam1\",\"Exp1Cam2\",\"Exp1Cam3\",\"Exp1Cam4\",\"Exp2Cam1\",\"Exp2Cam2\",\"Exp2Cam3\",\"Exp2Cam4\",\"NA\".")
	input(desc, "MitoTracker", "Marker4Description", type="String", description="Description of the second marker (ex. RFP) or NA. Do not use space or any other special characters.")
	if(desc=="NA" || Name=="NA")
		set(desc="NA",Name="NA")
	end()
	input(cutOff, 150, "Marker4 Positive cutOff", type="i",  description="Cut-off value to use to define. Allowed range: 1..5000, step 1.0.")
	Set(cutOff=iif(cutOff<1,1,cutOff))
	push(chanPurpose,"marker")
	push(chanNames,Name)
	push(chanDesc,desc)
	push(chanMin,0)
	push(chanCutOff,cutOff)

	set(chanInfo=tbl(name=chanNames, desc=chanDesc,min=chanMin,purpose=chanPurpose, cutOff=chanCutOff))
}


proc paramInit(memblock param out){
	input(showIllustrations, false, "showIllustrations", type="b", description="Indicate whether or not you want to see the illustrations for the objects detected. Used in combination with fieldToAnalyze. This option is deactivated on the RMCA.")
	EnvInfo()
	Set(showIllustrations=showIllustrations && env_interactive && env_supports_graphview && env_supports_htmlview && env_supports_imageview && env_supports_tableview)
	input(fieldSelected, 1, "fieldToAnalyze", type="i", description="If show illustration is selected, only analyze the selected field. use \"0\" to analyze every fields.")
	input(getSingleCellFeatures, false, "Save Single-Cell Features", type="b", description="Indicate whether or not you want to save the single cell features to a file.")
	input(getROI, false, "Save ROI", type="b", description="Indicate whether or not you want to save the Nuclear and cellular outlines to a file.")
	input(OutputStatType, "Median", "Well Aggregation", type="String", description="Select how the multiple fields should be agregated accross Channles. Allowed values: \"Mean\", \"Median\",\"Min\",\"Max\",\"Sum\".")
	input(cutOffType, "threshold", "Cut-Off type", type="string", description="Enter the type of cutt-off you wish to use. Each of these methods corresponds to: \"threshold: intensity of the cell to be considered positive\" \"folds: number of fold above the background to be considered as positive\", \" stddev: number of bckground standard deviation to be considered as positive\". Allowed values: \"threshold\", \"folds\", \"stddev\".")
	if(cutOffType!="threshold"&&cutOffType!="folds"&&cutOffType!="stddev")
		error("The Cut-Off type must be either  \"threshold\", \"folds\" or \"stddev\"")
	end()
	Pack(param,*)
	keep(param)
}

proc imageAnalysis(memblock images in, memblock param in, memblock sourceDataProp in, container imageData out){
	Unpack(param)
	set(cytoChanNum=chanInfo.number[findElem("cytoDetection",chanInfo.purpose).pos])
	set(nucChanNum=chanInfo.number[findElem("nucDetection",chanInfo.purpose).pos])
	set(membraneChanNum=chanInfo.number[findElem("membraneDetection",chanInfo.purpose).pos])
	set(spotsChanNum=chanInfo.number[findElem("spotsDetection",chanInfo.purpose).pos])
	set(nucChanMin=chanInfo.min[findElem("nucDetection",chanInfo.purpose).pos])
	set(imageData=cnt())
	if(images[nucChanNum].image.max>nucChanMin)
		bckGndSubstraction(-1,images=images)

		set(minNucIntensity=images[nucChanNum].bckGndSubstracted+1)

		//input(NucleiNormalization,3,"NucleiNormalization:Nuclei Detection","d","remove nuclei with a roundness or area which is x standard deviation above or bellow the mean value.")
		set(nucImage=images[nucChanNum].image)
		Nuclei_Detection(nucImage,fileDir=sourceDataProp.fileDir)

		if(cytoChanNum>=0)
			if(membraneChanNum>=0)
				set(image=images[membraneChanNum].image)
				convert(bpp=1)
				rename(membrane=image)
			end()
			set(cytoImage=images[cytoChanNum].image)
			//set(minCytoIntensity=stdDevToSubstract*bckGndObjects["Body_"&images[cytoChanNum].desc&"_StdDevIntensity"].mean)
			convert(bpp=1,image=cytoImage)

			Cytoplasm_Detection_Select(reference=image)
			//normalizeObjects(NucleiNormalization,image=nucImage,objects=nuclei)

			Stencil2Objects(nuclei.body, CalcArea=false)
			CalcMassCentre()
			rename(nuclei=objects,objects=wholeCells)

			Stencil2Objects(objects.body)
			SetAttr(centers,objects.body&&nuclei.body.mask.image)
			SetAttr(cytoplasm,objects.body&& !nuclei.body.mask.image)
			CalcStat("sum",AttrName="NumberOfNuclei",image=Nuclei.masscentre.mask.image)
			input(MembraneSize, 0, "MembraneSize: Membrane Region", "i", "Size of the membrane Unit is image pixel. . Allowed range: 0..20, step 2.")
			input(Region,"Nuclei","Spots Region: Spot Detection",type="s",description="Specifies the region in which the spots should be located. Allowed values:\"Nuclei\",\"Cytoplasm\",\"WholeCells\".")
			if(MembraneSize>0)
				Set(MembraneSize=Ceil(MembraneSize/2))
				RingRegion_inner(-1*MembraneSize,MembraneSize,stencil="centers",RegionName="NuclearEnveloppe",ShowRegionBorder=false,VisualImage=nucImage,WholeCells=objects|objects=wholeCells)
				RingRegion_inner(-1*MembraneSize,MembraneSize,stencil="body",RegionName="PlasmaMembrane",ShowRegionBorder=false,VisualImage=cytoImage,WholeCells=objects|objects=wholeCells)
				SetAttr(cytoplasm,!(NuclearEnveloppe.mask || PlasmaMembrane.mask)&&cytoplasm)
			end()
			RenameAttr(Nuclei=centers)
			getFeatures()
			Rename(WholeCells=objects)

			Stencil2Objects(wholeCells.Nuclei, CalcArea=false)
			CalcFeatures(images=vec(images[nucChanNum]),parentNames=vec("WholeCells"),parentObjects=cnt(WholeCells=WholeCells))
			Rename(Nuclei=objects)
			Set(imageData.bckGndObjects=bckGndObjects,imageData.Nuclei=Nuclei,imageData.WholeCells=WholeCells)
		else()
			Stencil2Objects(nuclei.body, CalcArea=false)
			input(MembraneSize, 0, "MembraneSize: Membrane Region", "i", "Size of the membrane Unit is image pixel. . Allowed range: 0..20, step 2.")
			input(Region,"Nuclei","Spots Region: Spot Detection",type="s",description="Specifies the region in which the spots should be located. Allowed values:\"Nuclei\",\"Cytoplasm\",\"WholeCells\".")
			if(MembraneSize>0)
				RingRegion_inner(-1*MembraneSize,MembraneSize,stencil="body",RegionName="NuclearEnveloppe",ShowRegionBorder=false,VisualImage=nucImage,WholeCells=objects|objects=wholeCells)
			end()
			//normalizeObjects(NucleiNormalization,image=nucImage,objects=nuclei)
			getFeatures()
			Rename(Nuclei=objects)
			Set(imageData.bckGndObjects=bckGndObjects,imageData.Nuclei=Nuclei)
		end()
		if(spotsChanNum>=0)
			if(Region!="Nuclei"&& ! Defined("WholeCells"))
				warning("Cannot extract the spots from an unexisting region. No spots will be returned")
				return()
			end()
			if(Region=="Nuclei")
				Set(objects=imageData.Nuclei)
			else()
				Set(objects=imageData.WholeCells)
			end()
			Set(SearchRegion=iif(Region=="Cytoplasm","Cytoplasm","Body"))
			SpotDetection(images[spotsChanNum].image,ShowOutputParameters=false,WholeCells=objects)
			CalcStat("Sum",AttrName="NumberOfSpots",image=spots.spotCenters.mask.image)

			if(Region=="Nuclei"&& ! Defined("imageData.WholeCells"))
				Set(imageData.Nuclei=objects)
				set(parentNames=vec("Nuclei"),parentObjects=cnt(Nuclei=ImageData.Nuclei))
			else()
				Set(ImageData.WholeCells=objects)
				set(parentNames=vec("Nuclei,WholeCells"),parentObjects=cnt(Nuclei=ImageData.Nuclei,WholeCells=ImageData.WholeCells))
			end()
			Stencil2Objects(Spots.body,CalcArea=true)
			CalcFeatures(images=images,CalcMorphologyFeatures=true,CalcCorrelationFeatures=true,parentNames=parentNames,parentObjects=parentObjects)
			Set(Objects["Body_"&images[spotsChanNum].Desc&"_Intensity"&Region&"Contrast"]=Spots.SpotToCellIntensity)
			Set(imageData.Spots=objects)
		end()
	end()
}

proc Analysis(memblock images in,memblock param in, memblock sourceDataProp inout, container data out){

	set(wholeWellData=cnt())
	set(numFieldsInFocus=0)
	Set(FeaturesTable=Tbl(),ROITable=Tbl())
	if(images.length>0)
	foreach(0..images.length-1, "field")
	foreach(0..images[field].length-1, "stack")
		imageAnalysis(images[field][stack],param)
		if(imageData.length>0)
			set(numFieldsInFocus=numFieldsInFocus+1)
			if(param.getROI)
				if(defined("imageData.Nuclei"))
					getROITable(imageData.Nuclei,ObjectType="Nuclei")
				end()
				if(defined("imageData.WholeCells"))
					getROITable(imageData.WholeCells,ObjectType="WholeCells")
				end()
			end()
			if(param.getSingleCellFeatures)
				Foreach(imageData.keys,"keyName")
					Set(objects=ImageData[keyName])
						if(objects.class=="objectlist"||objects.class=="compositObjectlist")
							try() //Skip objects that do not have a real setncil stencil and for which a center of mass can be determined.
								getFeaturesTable(objects,ObjectType=keyname)
							Catch_Error()
							end()
						end()
				end()
			end()

			combineMemBlocks(wholeWellData, imageData,DeleteGeometry=true,KeepAutoRecalc=false)
			rename(wholeWellData=newData)
		end()
		delete(imageData)
	end()
	end()
	end()

	Set(singleCellData=Cnt())
	if(param.getSingleCellFeatures)
		Set(singleCellData.Features=FeaturesTable)
	end()
	if(param.getROI)
		Set(singleCellData.ROI=ROITable)
	end()
	set(wholeWellData.numFieldsInFocus=numFieldsInFocus)
	pack(data,wholeWellData,singleCellData)
}

//#######################
// Program Start
//#######################
getChanInfo()
ParamInit()
ImagesInit()
chanAttrib()
set(param.chanInfo=chanInfo)
if(param.showIllustrations&&param.fieldSelected!=0)
	set(param.fieldSelected=iif(param.fieldSelected<1,1,param.fieldSelected))
	set(param.fieldSelected=iif(param.fieldSelected>images.length,images.length,param.fieldSelected))
	set(Images=vec(images[param.fieldSelected-1]))
end()

Analysis()
writeChannelMapping(images, sourcedataprop.fileDir,sourcedataprop.WellIndex)
dataOutput(data,sourcedataprop,param.OutputStatType)