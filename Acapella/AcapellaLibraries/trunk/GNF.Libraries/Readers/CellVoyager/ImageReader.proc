//#############################################################################################
//# Acapella Script and procedures Collection: A collection of Acapella based scripts
//# and libraries.
//#
//# Please acknowledge the author(s)/contributor(s) for making use of these scripts and library.
//# Authors:
//#   * Ghislain M.C. Bonamy
//#   * Genomics Institute of the Novartis Research Foundation (GNF), San Diego, CA 92122
//#   * www.gnf.org
//#
//# You can obtain the latest version of this software at: http://code.google.com/p/operahci/
//#
//# This program is free software; you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation; either version 2 of the License, or
//# (at your option) any later version.
//#
//# This program is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with this program; if not, write to the Free Software
//# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//# or go to: http://www.apache.org/licenses/
//#############################################################################################

//*********************************************************************************************
//*
//* InCell Procedure for extracting images information, reading images and getting wellIDs
//* or list of images for a given well index
//*
//*********************************************************************************************

proc filename_to_wellindex(
	string filename in,
	string wellindex out
) [hidden] ImageReader "Enables translating a filename into a well index"
{
	Readers::CellVoyager::getEncodedProps(filename)
	if(encodedProps.length==0)
		Error("The file selected: '"&filename&"' does not appear to be a valid InCell file.")
	end()

	set(row=encodedProps.row)
	set(col=encodedProps.col)
	//set(field=1*encodedProps.field)

	//Note working using well level images as opposed to field level images hence last 3 digits are '0s'
	sprintf(wellindex,"%03d%03d000",row,col)
}

proc wellindex_to_filenames(
	string wellindex in,
	string imagetype="" in,
	string basepath="" in,
	container filenames out,
	string available_imagetype out
) [hidden] ImageReader "Enables translating a well index into a filename"
{

	// wellindex needs to have 9 digits
	sprintf(wellindex,"%09d",1*wellindex)

	set(basePath=regexreplace(basePath,"\\\\","/").text)
	if(at("/",basePath,-1)!=basePath.length)
		set(basePath=basePath&"/")
	end()

	set(row=1*substr(wellindex, 1, 3))
	set(col=1*substr(wellindex, 4, 3))
	//Work with well level and not field level images, commenting next line out
	//Set(field=1*substr(wellindex,7,3))
	Readers::row2str(row)
	sprintf(WellString,"%s%s - %s(fld*wv*).tif",basepath,row,col)

	// search all image files for this well
	glob( WellString, ignorecase=true, warning=false)
	set(files=sort(files).result)
	set(filenames_str=basePath)
	foreach(files, "filename")
		Readers::CellVoyager::getEncodedProps(filename)
		if(encodedProps.length==0)
			Warning("The file selected: '"&filename&"' does not appear to be a valid InCell file. Skipping the file")
			Continue()
		end()


		//bug in the code between wellindex_to_filenames from index.script and readimage.script, which prevent
		//the image file variable to be correctly generated
		//set(filenames["c" & channel] = filename)
		set(filenames_str=filenames_str&":"&encodedProps.filename)
	end()


	set(filenames=cnt())
	set(filenames.c1=filenames_str)
	if (filenames.size == 0 && files.size == 1)
		set( filename = files[0])
		set (channel = channo(filename))
		if (expno(filename)=="" || channel == 0)
			// there was exactly one match, but expno deduction did not work (because there was no number in the filename).
			// assume the filename is for channel 1.
			set(filenames.c1 = files[0])
		end()
	end()
	set(available_imagetype="") // unknown
}


proc filenames_to_images(
	vector imagefile in,
	table sourcedata out,
	container sourcedataprop out
) [hidden] ImageReader "read the images and fetches the metadata for them."
{

	splitstring(imagefile,":")
	rename(filenames=split)
	set(basePath=filenames[0])
	pop(filenames,pos=0)
	if(basePath.length==1) //Dealing with Mapped drives
		set(basePath=basePath & ":" & filenames[0])
		pop(filenames,pos=0)
	end()
	set(basePath=regexreplace(basePath,"\\\\","/").text)

	if(at("/",basePath,-1)!=basePath.length)
		set(basePath=basePath & "/")
	end()
	set(filenames=vec(basePath) & filenames)

	set(filenames=sort(filenames).result)
	set(filePaths=cnt())
	set(channels=vec())
	set(tempSourcedata=cnt())
	set(index=0)
	foreach(filenames, "filePath")
		Readers::CellVoyager::getEncodedProps(filePath)
		if(encodedProps.length==0)
			Warning("The file selected: '"&filePath&"' does not appear to be a valid InCell file. It does not match the pattern. Skipping the file.")
			Continue()
		end()

		try()
			readimage(filePath,"tif")
		catch_error()
			Warning("The file selected: '"&filePath&"' does not appear to be a valid InCell file. The following error was returned when reading the file: '"&catch_message&"'. Skipping the file.")
			Continue()
		end()

		if(available_images!=1)
			Warning("The file selected: '"&filePath&"' does not appear to be a valid InCell file. It does not encode a single plan tif image. Skipping the file.")
			Continue()
		end()

		push(SourceImage,image)
		delete(image)

		//Transfer all the properties registered into encodedProps
		foreach(encodedProps.keys)
			if(i=="")
				continue()
			end()
			push(tempSourcedata[i],encodedProps[i])
		end()


		// determine its channel#:
		set(chanName=encodedProps.FilterCombinationRef)
		if(channels.length==0)
			set(channel_num=-1)
		else()
			set(channel_num=findElem(chanName,channels).pos)
		end()
		push(encodedProps.Channel,channel_num)
		push(encodedProps.ChannelID,channel_num)
		if(channel_num==-1)
			push(channels,chanName)
			set(channel_num=channels.length-1)
		end()
		//Print The proper exposures and Camera (max 4 cameras)
		sprintf(ChannelName,"Exp%1dCam%2d",channel_num~4+1,int(channel_num/4)+1)
		push(tempSourcedata.ChannelName,ChannelName)
		push(tempSourcedata.Name,ChannelName) //Kept for old script compatibility

		push(tempSourcedata.FrameIndex,index)
		set(index=index+1)
	end()


	set(sourcedata=tbl())
	Foreach(tempSourcedata.keys)
		push(sourcedata[i],tempSourcedata[i])
	end()
	if(!defined("SourceImage"))
		error("The well requested does not appear to have been acquired on an InCell Instrument.")
	end()
	if(SourceImage.length<1 || SourceImage.length!=sourcedata.rowcount)
		error("The well requested does not appear to have been acquired on an InCell Instrument.")
	end()
	Set(sourcedata.SourceImage=SourceImage)
	delete(SourceImage)

	set(sourcedataprop=cnt())
	Set(sourcedataprop.NumberOfImages=sourcedata.rowcount)
	Set(sourcedataprop.NumberOfChannels=uniq(Channel).result.length)
	Set(sourcedataprop.NumberOfFields=uniq(Field).result.length)
	Set(sourcedataprop.NumberOfPlanes=uniq(Plane).result.length)
	Set(sourcedataprop.NumberOfTimepoints=uniq(Timepoint).result.length)
	Set(sourcedataprop.ProviderName="Yokogawa-CellVoyager")
	Set(sourcedataprop.WellIndex=filename_to_wellindex(filenames[0]).wellindex)
	Readers::wellName(sourcedataprop.WellIndex)
	Set(sourcedataprop.WellName=WellName)

	//follow opera convention filename is really filepath, cf ExperimentInfoParser.proc extracting of fileDir
	Set(sourcedataprop.SourceFileName=filePaths)
}

proc getEncodedProps(string filePath in, vector encodedProps out)[hidden]{
	// typical format of the filePath:
	//./<ProjectID>/<AnalysisName>_<AssayName>_<AssayDate[YYYYMMDD]>_<AssayTime[HHMMSS]>/<Assay_Plate[ID|Name]>/<Assay_Plate[ID|Name]>_<WellID>_T<TimeID[0001-9999]>F<FieldID[001-999]>L<TimeLine[01-99]>A<Action=Exposure[01-99]>Z<ZStackIndex[01-99]>C<Channel#[01-99]>.tif
	//eg: ./MyProjrct/Test_scilia assay_20130313_105517/Greiner_non coated/Greiner_non coated_C08_T0001F001L01A01Z01C02.tif
	set(filePath=regexreplace(filePath,"\\\\","/").text)
	Regex(filePath,"^.+?/([^/]+?)/(?:([^/_]+)_)?([^/_]+?)_(\\d{8})_(\\d{6})/([^/]+)/(\\6_([A-Z]{1,2})(\\d{2})_T(\\d{4})F(\\d{3})L(\\d{2})A(\\d{2})Z(\\d{2})C(\\d{2})\\.tif$)")

	Set(encodedProps=cnt())
	if(matches.length==0)
		Return()
	end()

	Set(encodedProps.ExpID=matches[4] &"-"& matches[5])
	Set(encodedProps.Barcode=matches[6])
	Set(encodedProps.PlateName=encodedProps.Barcode)
	Set(encodedProps.Exp_Num=1*matches[10])
	Set(encodedProps.PlateID = sprintf( "text", "%s_%s_%02d",encodedProps.ExpID, encodedProps. Barcode, encodedProps.Exp_Num ).text )

	Set(encodedProps.filename=matches[7])
	Set(row_str=matches[8])
	Set(encodedProps.Row_str = row_str)
	Readers::row2num(row_str)
	Set(encodedProps.Row=1*row_n)
	Set(encodedProps.Col=1*matches[9])
	Set(encodedProps.Column=encodedProps.Col)

	//Get the list of properties of the image
	Set(encodedProps.Field=1*matches[11])
	Set(encodedProps.Exposure=1*matches[13])
	Set(encodedProps.Channel=1*matches[15])
	Set(encodedProps.FilterCombinationRef=sprintf( "text", "%02d-%02d",encodedProps.Exposure, encodedProps.Channel ).text)
	Set(encodedProps.Plane=1*matches[14])
	Set(encodedProps.Timepoint=1*matches[12])

}