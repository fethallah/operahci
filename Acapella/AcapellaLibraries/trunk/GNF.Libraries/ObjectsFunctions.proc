//#############################################################################################
//# Acapella Script and procedures Collection: A collection of Acapella based scripts
//# and libraries.
//#
//# Please acknowledge the author(s)/contributor(s) for making use of these scripts and library.
//# Authors:
//#   * Ghislain M.C. Bonamy
//#   * Genomics Institute of the Novartis Research Foundation (GNF), San Diego, CA 92122
//#   * www.gnf.org
//#
//# You can obtain the latest version of this software at: http://code.google.com/p/operahci/
//#
//# This program is free software; you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation; either version 2 of the License, or
//# (at your option) any later version.
//#
//# This program is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with this program; if not, write to the Free Software
//# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//# or go to: http://www.apache.org/licenses/
//#############################################################################################

//*********************************************************************************************
//*
//* This library defines a set of procedures used to generate and work with objectlists.
//* It also provides tools to generate, validate and work with new type of objects.
//*
//*********************************************************************************************


proc containedObjects(
//INPUT
objectList Container in "List of objects that should contain and/or overlap with the objects in the list provide \"Objects\".",
objectList Objects in "List of objects for which inclusion and/or overlap should be returned.",
objectList Remainder out "List of objects that are not contained and/or overlapping with \"Container\".",
objectList objects out "List of objects that are not contained and/or overlapping with \"Container\". This list has attributes / stencil added",
String objectsStencil="body" in "Optional input. Stencil to use in the list \"Objects\".",
String ContainerStencil="body" in "Optional input. Stencil to use in the list \"Container\".",
boolean overlap=true in "Optional input. Indicate whether the objects in \"Objects\" can simply overlap (true), or whether they need to be contained within \"Container\" (false)."
) mask operations,object list manipulations "Split the object lits provided into an objects list containing objects that are contained or overlapping with the \"Container\" and the remainder containing objects that are not overlapping and/or contained in \"Container\""
{
	set(image=Container[""&ContainerStencil].mask.image)
	And(image,image=Objects[""&ObjectsStencil].mask.image)
	set(AttributePrefix=iif(objectsStencil!="body",objectsStencil&"_",""))
	if(defined("Objects."&AttributePrefix&"intensity"))
		Eval("RenameAttr(intensityTemp="&AttributePrefix&"intensity)")
	end()
	Eval("CalcIntensity("&objectsStencil&",image,AutoRecalc=false)")
	rename(iniOverlap=image)
	if(objectsStencil!="body")
		set(factor=objectsStencil&"_Intensity")
	else()
		set(factor="Intensity")
	end()

	if(overlap)
		splitMyObjects(factor&">0")
	else()
		splitMyObjects(factor&">=1")
	end()
	eval("deleteAttr("&factor&")")
	eval("deleteAttr("&factor&",objects=remainder|remainder=objects)")
	if(defined("Objects.intensityTemp"))
		Eval("RenameAttr("&AttributePrefix&"intensity=intensityTemp)")
	end()
	if(defined("remainder.intensityTemp"))
		rename(tempObjects=objects)
		Eval("RenameAttr("&AttributePrefix&"intensity=intensityTemp,objects=remainder)")
		rename(remainder=objects,objects=tempObjects)
	end()

	keep(remainder, objects)
}

proc addContainedObjectsInfo(
//INPUT
objectList containedObjects in "List of objects that should be contained within the objects in the list provided \"Objects\".",
objectList Objects=Objects in "List of objects to which  \"containedObjects\" should be mapped.",
objectList objects out "Original object list returned with added attribute: \"objectsStencil_outputStencil\"_count, and added stencil \"objectsStencil_outputStencil\", \"objectsStencil_outputStencil\"_border, \"objectsStencil_outputStencil\"_massCentre.",
String containedObjectsStencil="body" in "Optional input. Stencil to use in the list \"containedObjects\".",
String objectsStencil="body" in "Optional input. Stencil to use in the list \"objects\".",
String outputStencil="ObjectsContained" in "Optional input. Base name for the outputed stencil and attributes in \"objects\".",
) mask operations,object list manipulations "Split the object list provided into an objects list containing objects that are contained or overlapping with the \"Container\" and the remainder containing objects that are not overlapping and/or contained in \"Container\""
{
	rename(objectsIni=objects)
	eval("CalcMassCentre("&containedObjectsStencil&",objects=containedObjects,Autorecalc=false)")
	set(AttributePrefix=iif(containedObjectsStencil!="body",containedObjectsStencil&"_",""))
	rename(containedObjects=objects,objects=objectsini)

	set(image=containedObjects[AttributePrefix&"massCentre"].mask.image)

	if(defined("objects.intensity"))
		RenameAttr(intensityTemp=intensity)
	end()

	eval("CalcIntensity("&ObjectsStencil&",Image=image,Total=true,objects=objects)")
	set(AttributePrefix=iif(objectsStencil!="body",objectsStencil&"_",""))
	eval("RenameAttr("&AttributePrefix&outputStencil&"_count="&AttributePrefix&"intensity)")

	if(defined("objects.intensityTemp"))
		RenameAttr(intensity=intensityTemp)
	end()

	And(containedObjects[containedObjectsStencil].mask.image, image=Objects[""&ObjectsStencil])
	set(AttributePrefix=iif(objectsStencil!="body",objectsStencil&"_",""))
	SetAttr(""&AttributePrefix&outputStencil,image.vector, objects=objects)
	eval("calcborder("&AttributePrefix&outputStencil&", objects=objects)")

	set(AttributePrefix=iif(containedObjectsStencil!="body",containedObjectsStencil&"_",""))
	And(containedObjects[AttributePrefix&"massCentre"].mask.image, image=Objects[""&ObjectsStencil])
	set(AttributePrefix=iif(objectsStencil!="body",objectsStencil&"_",""))
	SetAttr(AttributePrefix&outputStencil&"_MassCentre",image.vector, objects=objects)
	keep(objects)
}

proc splitMyObjects(
String formula in "Formula for spliting the objectlist \"objects\".",
Memblock objects in "Object list containing the objects that should be split based on \"formula\".",
Memblock Remainder out "Objects that failed the criteria provided in \"formula\".",
Memblock objects out "Objects that satisfy the criteria provided in \"formula\"."
) object list manipulations "Split the object lits provided into two categories based on a formula. Example: formula=\"area != 30\" will return in \"Objects\" all the objects that have an area different from 30 and in \"Remainder\" all the objects with an area equal to 30"
{
	Set(formula=""&formula)
	Rename(objectsIni=objects)
	if(at(">=",formula,1)!=0)
		RegexReplace(formula,">=","<",first_only=true)
		set(opFormula=text)
	else()if(at(">",formula,1)!=0)
		RegexReplace(formula,">","<=",first_only=true)
		set(opFormula=text)
	else() if(at("<=",formula,1)!=0)
		RegexReplace(formula,"<=",">",first_only=true)
		set(opFormula=text)
	else() if(at("<",formula,1)!=0)
		RegexReplace(formula,"<",">=",first_only=true)
		set(opFormula=text)
	else() if(at("!=",formula,1)!=0)
		RegexReplace(formula,"!=","==",first_only=true)
		set(opFormula=text)
	else()if(at("==",formula,1)!=0)
		RegexReplace(formula,"==","!=",first_only=true)
		set(opFormula=text)
	else()
		Error("The formula provided for the module splitMyObjects is incorrect. It should contain the operand ==,!=, >, >=, <, <=")
	end()end()end()end()end()end()

	ObjectFilter(""&opFormula,objects=objectsIni)
	rename(remainder=objects)
	ObjectFilter(""&formula,objects=objectsIni)
	keep(objects,remainder)
}

proc bckGndDetection(
//INPUT
	image image inout "image to which background should be subtracted",
	boolean showIllustrations = false in "indicate whether you wish to see the illustration of the area corresponding to the background.",
	boolean minLevel = 0 in "Used to remove from the background object mask pixels bellow this value. Useful to remove border of a well for instance. Adjust with \"Area considered as Background\". Lower value reduces the number of pixels excluded.",
	boolean includeBorders = true in "Optional. Indicate whether you want to remove pixels detected in the background objects that are at the border of the image. Use this option if you are sure the edge of the well will not be included in the image. This can be overwritten by setting the input to true. Select depending on the background illustration.",
//OUTPUT
	objectList objects out "Object representing the background pixels. This objects contain the attribute intensity which corresponds the the BckGnd intensity of the image provided. And the stencil body/border corresponding the area corresponding to the background.",
	double stdDevToSubstract=0 inout "Optional: Indicate how many standard deviation of the noise should be considered as background.",
) object list manipulations "This procedure detects the object containing the background pixels"
{
	set(imageIni=image)
	if(minLevel==0)
		input(minLevel,0,"Min Channel Level: Background detection",Type="i", description="Used to remove from the background object mask pixels bellow this value. Useful to remove border of a well for instance. Adjust with \"Area considered as Background\". Lower value reduces the number of pixels excluded. Allowed range: 0..1000.")
	end()
	input(BckGndFactor,5,"Background Factor: Background detection",Type="d", description="Setting to find pixels devoid of cells in the image. Adjust with \"Area considered as Background\". Lower value result in more pixels (ie. pixels of higher value) being considered as background. Use 0 if you wish to skip background detection. Allowed range: 0..100, step 0.1.")

	input(includeBorderInput,true,"Include Borders: Background detection",Type="b", description="Enter Whether to use the objects touching the border as part of the background")
	if(Not(includeBorderInput))
		set(includeBorders=includeBorderInput)
	end()
	if(stdDevToSubstract==0)
		input(stdDevToSubstract,0,"NoiseSTDEV2Substract: Background detection",Type="d", description="Optional: Indicate how many standard deviation of the noise should be considered as background. Allowed range: 0..10, step 0.1.")
	end()
	
	if(BckGndFactor==0)
		set(objects=create("ObjectList").objectList)
		return()
	end()

	set(minLevelVec=tabulate("x*20",15).result)
	
	//Round the different values to 1 decimal
	tabulate("1.2^(1.2*x-2)",15)
	convElems(result*10,"integer")
	convElems(result/10,"float")
	rename(bckGndFactorVec=result)
	
	//Round the different values to 1 decimal
	tabulate("(x*0.5)",10)
	convElems(result*10,"integer")
	convElems(result/10,"float")
	rename(stdDevToSubstractVec=result)
	
	input(ScanParameter, "None", "Parameter SCAN: Background detection", "s", "Controls the parameter to scan. Use  the default value \"None\" for the standard evaluation (parameter scan is not applied). If you would like to adjust a parameter, please select it from \"Parameter SCAN\" menu and click to Run. The procedure scans the parameter over the whole range and depicts the corresponding detection results. Inspect the results for the different parameter values and try to select one, which provides the best bckground detection. Possible values: \"None\", \"Min Channel Level\",\"Background Factor\".") //, \"NoiseSTDEV2Substract\".") //TODO: implement scanning for STDEV substraction, need to modify the bckgnd subtraction + use images rather than composed image.
	//ensures that you use the actuall parameters with RMCA or Linux
	EnvInfo()
	Set(ScanParameter=iif(env_interactive && env_supports_graphview && env_supports_htmlview && env_supports_imageview && env_supports_tableview,ScanParameter,"None"))
	
	if(ScanParameter=="none")
		set(scanVec=vec(0))
		set(scanning=false)
	else()
		set(scanning=true)
	end()

	if(ScanParameter=="Min Channel Level")
		set(scanVec=minLevelVec)
	end()
	if(ScanParameter=="Background Factor")
		set(scanVec=bckGndFactorVec)
	end()
	if(ScanParameter=="NoiseSTDEV2Substract")
		set(scanVec=stdDevToSubstractVec)
	end()

	
	foreach(scanVec)
		if(ScanParameter=="Min Channel Level")
			set(minLevel =i)
		end()
		if(ScanParameter=="Background Factor")
			set(bckGndFactor =i)
		end()
		if(ScanParameter=="NoiseSTDEV2Substract")
			set(stdDevToSubstract =i)
		end()
		
		bckGndDetection_Inner(imageIni, bckGndFactor=bckGndFactor, minLevel=minLevel, showIllustrations = !scanning&&showIllustrations) //do not display illustrations in scanning mode
		
		if(scanning && showIllustrations)
			set(TitleSufix=ScanParameter&"="&i)
			set(label=":"&i)
			imageview(objects.border, "bckGndBord"&label, image=imageIni, gamma=2.6, title="Border of the background detected for: "&TitleSufix)
			imageview(objects.body,"bckGndBody"&label, image=imageIni, gamma=2.6, title="Body of the background detected for: "&TitleSufix)
			
			//TODO: Show images after subtraction for varying StdDev removal.
		end()
	end()

	if(scanning)
		stop()
	end()
}

proc bckGndDetection_Inner(
//INPUT
	image image inout "image to which background should be subtracted",
	double bckGndFactor=5 in "Setting to find pixels devoid of cells in the image. Adjust with \"Area considered as Background\". Lower value result in more pixels (ie. pixels of higher value) being considered as background: Background detection",
	boolean showIllustrations = false in "indicate whether you wish to see the illustration of the area corresponding to the background.",
	boolean minLevel = 0 in "Used to remove from the background object mask pixels bellow this value. Useful to remove border of a well for instance. Adjust with \"Area considered as Background\". Lower value reduces the number of pixels excluded.",
//OUTPUT
	objectList objects out "Object representing the background pixels. This objects contain the attribute intensity which corresponds the the BckGnd intensity of the image provided. And the stencil body/border corresponding the area corresponding to the background.",
	boolean includeBorders = true in "Optional. Indicate whether you want to remove pixels detected in the background objects that are at the border of the image. Use this option if you are sure the edge of the well will not be included in the image. This can be overwritten by setting the input to true. Select depending on the background illustration."
) object list manipulations "This procedure detects the object containing the background pixels"
{
	set(initImage=image)
	Set(image=image+1)
	cut(threshold=minLevel)
	set(BckGndFactorInit=BckGndFactor)
	mean(3,Faster=true)
	Remap(0,image.max,0,image.max)
	//convert(bpp=1,image=image-1)
	Set(image=image-1)
	set(smoothed=image)
	ThresholdXX(BckGndFactor)
	Mask()
	Not(image=MASK)
	Erosion(2)
	Mask(1)
	Mask2Stencil(Mask)
	Stencil2Objects()
	CalcArea()
	set(tempObjects=objects)
	if(Not(includeBorders))
		RemoveBorderObjects()
	end()

	set(bckGndMinArea=100)
	while((objects.count<1  || objects.area.sum<bckGndMinArea)&& BckGndFactor >0.1)
		set(image=tempObjects.body.mask.image*smoothed.max)
		set(image=image+smoothed)
		set(BckGndFactor=BckGndFactor/1.2)
		ThresholdXX(BckGndFactor)
		Mask()
		Not(image=MASK)
		Erosion(2)
		Mask(1)
		Mask2Stencil(Mask)
		Stencil2Objects()
		CalcArea()

		set(tempObjects=objects)
		if(Not(includeBorders))
			RemoveBorderObjects()
		end()
	end()

	if(BckGndFactor <=0.1)
		set(image=smoothed)
		ThresholdXX(BckGndFactorInit)
		Mask()
		Not(image=MASK)
		Erosion(2)
		Mask(1)
		Mask2Stencil(Mask)
		Stencil2Objects()
	end()
	Mask2Stencil(objects.body.mask,Method="One large object")
	Stencil2Objects()
	CalcArea()
	delete(mask,stencil,smoothed)

	if(showIllustrations)
		imageview(item=objects.border, label="BckGround", title="Area considered as Background", image=initImage, gamma=2.0)
	end()
}

proc bckGndSubstraction(
	int chanNum = -1 in "Index of the image to use for the background detection. Use -1 to make a composite image (max projection used to detect background).",
	boolean includeBorders = true in "Optional. Indicate whether you want to remove pixels detected in the background objects that are at the border of the image. Use this option if you are sure the edge of the well will not be included in the image. This can be overwritten by setting the input to true. Select depending on the background illustration.",
	boolean showIllustrations = false in "indicate whether you wish to see the illustration of the area corresponding to the background.",
	double stdDevToSubstract = 0 inout "Optional. Number of standard deviation for the background intensity to subtract from the images in addition to the mean. Adjust using the image in \"Area considered as Background\" when using the showwIllustrations option.",
	vector images inout "Container containing all the channels from a given field-section. The returned images have been background subtracted and the attribute\"bckGndSubstracted\" is added.",
	objectList bckGndObjects out "Object list corresponding to the area containing the background, the area used by the background, the intensity, and the intensity stdDev",
) Image Manipulation "Removes the background from the images contained in the container"
{
		if(defined("images["&chanNum&"]"))
			set(image=images[chanNum].image)
		else()
			set(image=images[0].image)
			convert(2)
			if(images.length>1)
				foreach(1..images.length-1,"chan")
					Paste(images[chan].image,image=image, method="max")
				end()
			end()
		end()
		bckGndDetection(image)
		Set(isEmptyObjects=objects.count==1)
		Foreach(0..images.length-1)
			set(image=images[i].image)
			if(isEmptyObjects)
				CalcIntensity(image=image, AutoRecalc=false,CalcStdDev=true)
				if(isNan(objects.intensity.mean))
					Set(object.intensity=vec(0))
				end()
				if(isNan(objects.intensity_stddev.mean))
					Set(object.intensity_stddev=vec(0))
				end()
			else()
				Set(objects.intensity=vec(0))
				Set(objects.intensity_stddev=vec(0))
			end()
			
			set(bckGndSubstracted=objects.intensity.mean+stdDevToSubstract*objects.intensity_stddev.mean)
			add(-1*bckGndSubstracted,0,image=images[i].image)
			set(images[i].image=image,images[i].bckGndSubstracted=bckGndSubstracted)
			Set(Objects["Body_"&images[i].desc&"_MeanIntensity"]=objects.intensity)
			Set(Objects["Body_"&images[i].desc&"_StdDevIntensity"]=objects.intensity_StdDev)
			DeleteAttr(intensity, intensity_StdDev)
		end()

		Rename(bckGndObjects=objects)
}

proc combineMemBlocksV0(
	polytype oldData = none in  "Contains the info about the original data.",
	polytype newData in "Contains the info about the data to add",
	polytype newData out "Contains the new combined data",
	boolean deleteGeometry = false in "Used if objects is ObjectList type. Deletes the geometric attributes (Body, Border, Index, Zone, OuterZone) from the resulting object list. This avoids the possibility to have overlapping objects. Use this flag if the object lists might contain overlaps and you are not interested in the geometrical attributes afterwards. Parameter introduced in Cells library ver. 1.4.1.41",
	boolean KeepAutoRecalc = false in "Used if objects is ObjectList type. This parameter affects the attributes which have marked re-calculatable in both object lists. If KeepAutoRecalc is switched on these attributes preserve their AutoRecalc support, otherwise they become static as all of the other attributes. Note that depending on the attribute nature the necessary information required for recalculation might have been lost after merging the object lists, so the default setting is \"off\". Parameter introduced in Cells library ver. 1.4.1.41. Previous behaviour was to preserve autorecalc flags always. "
)object list manipulations "Combine the info contained within a memblock from a polytype into another. For objectList, the addObjects method is used, for table and arrays, the append method is used, for any other data (double, integer, string etc.) the data is pushed into a vector."
{
	set(type=typeOf(newData))

	if(type=="memblock")
	if(newData.class=="objectlist"&&deleteGeometry)
		objectsDeleteGeometry(newData)
		rename(newData=objects)
	end()
		if(not(defined("oldData")))
			Return()
		end()
		if(typeOf(oldData)!="memblock"||oldData.length==0)
			Return()
		else()
			TypeInfo(newData)
			if(typeInfo.type=="objectList")
				if(defined("newData.zone")) //added to fix a bug with Acapella and/or recursive procedures. SHould be removed when bug is fixed.
					DeleteAttr(zone,objects=newData)
					rename(newData=objects)
				end()
				if(defined("newData.outerzone"))//added to fix a bug with Acapella and/or recursive procedures. SHould be removed when bug is fixed.
					DeleteAttr(outerzone,objects=newData)
					rename(newData=objects)
				end()
				if(deleteGeometry)
					objectsDeleteGeometry(newData)
					rename(newData=objects)
				end()
				AddObjects(newData,CheckOverlap=false,objects=oldData)
				Rename(newData=objects)
				Return()
			else() if(typeInfo.type=="array")
				Append(oldData,newData)
				rename(newData=oldData)
				Return()
			else()if(typeInfo.type=="table")
				AppendTable(oldData,newData)
				rename(newData=table)
				Return()
			else() if(typeInfo.type=="container" && newData.length==oldData.length)
				rename(data=newData)
				Foreach(0..data.length-1)
					set(keyName=data.keys[i])
					if(defined("oldData."keyName))
						combineMemBlocks(oldData[keyName], data[keyName])
						set(data[keyName]=newData)
					else()
						Warning("An memblock does not contain the same number of elements as the memblock it is added too. This object will set to empty")
						set(data[keyName]=cnt())
						Continue()
					end()
				end()
				rename(newData=data)
				Return()
			else()
				Warning("The new memblock \"newData\" can not be added to the previous memblock \"oldData\"")
				set(newData=cnt())
				return()
			end()end()end()end()
		end()
	else()

	end()
}


proc combineMemBlocks(
	polytype oldData = none in  "Contains the info about the original data.",
	polytype newData in "Contains the info about the data to add",
	polytype newData out "Contains the new combined data",
	boolean deleteGeometry = false in "Used if objects is ObjectList type. Deletes the geometric attributes (Body, Border, Index, Zone, OuterZone) from the resulting object list. This avoids the possibility to have overlapping objects. Use this flag if the object lists might contain overlaps and you are not interested in the geometrical attributes afterwards. Parameter introduced in Cells library ver. 1.4.1.41",
	boolean KeepAutoRecalc = false in "Used if objects is ObjectList type. This parameter affects the attributes which have marked recalcable in both object lists. If KeepAutoRecalc is switched on these attributes preserve their AutoRecalc support, otherwise they become static as all of the other attributes. Note that depending on the attribute nature the necessary information required for recalculation might have been lost after merging the object lists, so the default setting is \"off\". Parameter introduced in Cells library ver. 1.4.1.41. Previous behaviour was to preserve autorecalc flags always. "
)object list manipulations "Combine the info contained within a memblock from a polytype into another. For objectList, the addObjects method is used, for table and arrays, the append method is used, for any other data (double, integer, string etc.) the data is pushed into a vector."
{

	if(newData.class=="objectlist"&&deleteGeometry)
		objectsDeleteGeometry(newData)
		rename(newData=objects)
	end()
	if(typeOf(newData)!="memblock")
		if(typeOf(newData)=="string"||typeOf(newData)=="integer"||typeOf(newData)=="double")
				set(newData=vec(newData))
		else()
			warning("Cannot combine pointers or sharable")
		end()
	end()
	if(not(defined("oldData")))
		Return()
	end()
	if(oldData.length==0)
		return()
	end()

	if(newData.class=="container"||newData.class=="compositObjectlist")
		if(newData.length==oldData.length)
		rename(data=newData)
			Foreach(data.keys,"keyName")
				if(keyName!="class")
				if(defined("oldData[keyName]"))
					combineMemBlocks(oldData[keyName], data[keyName],deleteGeometry,KeepAutoRecalc)
					set(data[keyName]=newData)
				else()
					Warning("An memblock does not contain the same number of elements as the memblock it is added too. This object:"&keyName&" will be set to empty")
					set(data[keyName]=cnt())
					Continue()
				end()
				end()
			end()
			rename(newData=data)
			return()
		else()
			if(oldData.length!=0)
				Warning("The new memblock \"newData\" can not be added to the previous memblock \"oldData\", returning oldData")
			end()
			set(newData=oldData)
			return()
		end()
	end()



	if(newData.class=="objectList")
		if(defined("newData.zone")) //added to fix a bug with Acapella and/or recursive procedures. SHould be removed when bug is fixed.
			DeleteAttr(zone,objects=newData)
			rename(newData=objects)
		end()
		if(defined("newData.outerzone"))//added to fix a bug with Acapella and/or recursive procedures. SHould be removed when bug is fixed.
			DeleteAttr(outerzone,objects=newData)
			rename(newData=objects)
		end()
		AddObjects(newData,CheckOverlap=false,objects=oldData)
		Rename(newData=objects)
		Return()
	end()

	if(newData.class=="vector")
		Append(oldData,newData)
		rename(newData=oldData)
		Return()
	end()

	if(newData.class=="table")
		//AppendTable(oldData,newData)
		AccumulateTables(table=oldData)
		AccumulateTables(newData)
		CreateAccumulatedTable(|newData=table)
		delete(_accutbl)
		Return()
	end()
}

proc objectsDeleteGeometry(
	objectlist objects in "List of objects to for which the stencils should be removed",
	objectlist objects out "Objects without any stencil attributes",
)
{
	set(keys=objects.keys)
	Foreach(keys,"keyName")
		if(defined("objects[keyName][type]"))
			if(objects[keyName].type=="stencil"||objects[keyName].class=="intervalVector")
				eval("deleteAttr("&keyName&")")
			end()
		end()
	end()
return()
}

proc ObjectsDistances(
	objectlist objects in "Object for which distance should be calculated.",
	vector distances out "vector containing the distances between each objects pair.",
	vector shortestDistance out "vector containing the distance from each object center to the closest object center.",
	string stencil = "body" in "Stencil to use to calculate the distances.",
) statistics "Returns the pairwise distances between each the center of mass of the stecil in the object provided. In case where objects has fewer than 2 elements, distances and shortestDistance is set to 0. "
{
if(objects.count<2)
	set(distances=create("vector","double", objects.count, 0 ).vector,shortestDistance=create("vector","double", objects.count,  0).vector)
	Return()
end()
set(prefix=iif(stencil=="body","",stencil&"_"))
if(Not(defined("objects."&prefix &"masscentre")))
	CalcMassCentre()
End()

PairWiseDistance(objects[prefix &"masscentre"].x.target,objects[prefix &"masscentre"].y.target)
}

proc CalcWidthLengthSafe(
	int factor=2 in "safety factor. For very large objects use a larger factor. For small objects prefer a smaller factor to get more accurate measurment. In case of errors \"Half_width\" and \"full_legnth\" are set to 0. If fatcor=0, tries to calculate the best value to use.",
	Objectlist objects inout "Objects for wich Half_Width and Full_Length should be caclulated.",
	boolean Upto100=false in "NO- the length calculation is limited to 367 pixels. YES- the length calculation is limited to 100 pixels. YES option enables to avoid long time consuming and superfluous calculations in case of large objects in situation when these large objects are out of interest, correspond to artifacts etc.",
){
	Set(iniObjects=Objects)
	if(factor==0)
		set(factor=iif(Upto100,100,367))
		if(Not(defined("objects.area")))
			calcAttr(area)
			set(maxArea=objects.area.max)
			deleteAttr(area)
		else()
			set(maxArea=objects.area.max)
		end()
		Set(factor=ceil(2*(maxArea/pi)^0.5/factor))
	end()
	if(factor>1)
		set(iniObjects=objects)
		ReSizeDownscaledObjects(1/factor,objects.index.image)
	end()
	//binning(factor,factor, "median", image=iniObjects.index) // this reduces the dimensions by a factor of two
	//set( image.type = "stencil" )
	//Stencil2Objects(image.vector )
	Try()
		CalcWidthLength(Upto100=Upto100)
		if(factor>1)
			if(iniObjects.count!=objects.count)
				Rename(Temp=objects)
				ReSizeDownscaledObjects(factor,iniObjects.index.image,objects=Temp)
				Blank(objects.imageWidth, objects.imageheight)
				convert(4)
				rename(blank=image)
				CarryObjects(objects.body,temp.Full_Length,image=blank)
				CalcStat("mean",AttrName="Full_Length",objects=iniObjects|iniObjects=objects)
				CarryObjects(objects.body,temp.Half_Width,image=blank)
				CalcStat("mean",AttrName="Half_Width",objects=iniObjects|iniObjects=objects)
				set(objects=iniObjects)
			end()
		end()
	Catch_Error()
		Set(objects=iniObjects)
		create("vector",7,objects.count,0)
		setAttr(Full_Length,vector)
		setAttr(Half_Width,vector)
	end()
		rename(temp=objects,objects=iniObjects)
		setAttr(Full_Length,factor*temp.Full_Length)
		setAttr(Half_Width,factor*temp.Half_Width)
}

proc getROITable(
Memblock objects in "Object list contaning an attribute border to export",
Table ROITable=none inout "Table containing a list of ROI formated as polygons that were already calculated for other fields. If a table is provided new data will be append to it. This tables also maps each objects to an ObjectID, an ObjectType, a field number, a stack number and a time point number.",
int time=1 in "timeSeries number for the object provided",
int stack=1 in "z stack number for the object provided",
int field=1 in "field number for the object provided",

String ObjectType="" in "Type of the objects. Can be left blank or provided as wholeCells, Nuclei, Spots etc.",
) output "Returns a table containing the coordinates to the different ROI measured as a polygon. These coordinates can be mapped to single well values obtained via extractSingleWellValues"
{
	if(objects.class=="compositobjectlist")
		Set(Objects=Objects.FullSet)
	end()
	if(objects.class!="objectlist")
		Error("The object provided is not a compositObjectList not an ObjectList.")
	end()

	set(table=tbl())
	if((defined("ROItable")))
		Rename(table=ROItable)
	end()
	if((Not(defined("objects.border")) && Not(defined("objects.body")))|| objects.size==0)
		AppendTable(other=tbl(TimePoint=vec(),StackNum=vec(),FieldNum=vec(),ObjectType=vec(),ObjectID=vec(),BoundingBoxMinCoordinates=vec(),BoundingBoxMaxCoordinates=vec(),XYini=vec(), ChainCode=vec())|ROItable=table)
		Return()
	end()
	if(Not(defined("objects.border")))
		Calcborder()
	end()
	ExtractROI(objects.border)
	addObjectID()
	set(length=objects.count)
	AppendTable(other=tbl(TimePoint=create("vector", 0, length, time).vector,StackNum=create("vector", 0, length, stack).vector,FieldNum=create("vector", 0, length, field).vector,ObjectType=create("vector", 13, length, ObjectType).vector,ObjectID=Objects.ObjectID,BoundingBoxMinCoordinates=boundingBoxMinCoordinateList,BoundingBoxMaxCoordinates=boundingBoxMaxCoordinateList,XYini=inialCoordinate, ChainCode=chainCode),|ROItable=table)
}

proc getFeaturesTable(
	Memblock objects in "Object list contaning the features to export",
	Table FeaturesTable out "Table containing the features list mapped to each objects. This tables maps each objects to an ObjectID, an ObjectType, a field number, a stack number and a time point number, a ParentObjectType and a ParentObjectID.",
	//Objectlist objects out "Object list contaning the newly calculated features",
	Container parentObjects=none in "Container with the differnt objectLists to use as parents from objects. Ex, for spots, a container containing nuclei and/or whole Cells, would allow to classify spots to the correct parent. If nothing is provided the object is associated to \"WholeWell\". Use Pack(parentObjects,...) to generate this. Ex: pack(parentObjects,Nuclei,WholeCells).",
	Vector parentNames=none in "Vector containing the names for the parents in the order for which the mapping should be done. Objects with name at a  higher Index contain objects with lower index (ex. Nuclei should have a lower index than WholeCells). use vec(\"name1\",\"name2\",...)",
	//Vector images=none in "Conatainer containing the images for each channels (for a given stack & field). These images are used to calculate the object intensity-based feature for each objetcs. If no images is provided, these features are not returned. Images should have the form images[chanel].image & images[chanel].name. This can be obtained after using the ImagesInitV2() module and selecting a channel stack ex: set(images=ImagesInitV2().images[field][stack])",
	Table FeaturesTable=none in "Table containing the list of calculated features for this object measured on a previous stack/field/timepoint. If a table is provided new data will be append to it. This tables also maps each objects to an ObjectID, an ObjectType, a field number, a stack number and a time point number.",
	int stack=1 in "z stack number for the object provided",
	int field=1 in "field number for the object provided",
	int time=1 in "timeSeries number for the object provided",

	String ObjectType="" in "Type of the objects. Can be left blank or provided as wholeCells, Nuclei, Spots etc.",
) output "Returns a table containing the coordinates to the different features measured as for the object. These coordinates can be mapped to single well values obtained via extractSingleWellValues"
{
	if(objects.class=="compositobjectlist")
		Set(Objects=Objects.FullSet)
	end()
	if(objects.class!="objectlist")
		Error("The object provided is not a compositObjectList not an ObjectList.")
	end()

	set(table=tbl())
	if((defined("FeaturesTable")))
		Rename(table=FeaturesTable)
	end()
	if(objects.count==0)
		Rename(FeaturesTable=table)
		return()
	end()
	set(length=objects.count)
	if(Not(defined("Objects.parentType"))||Not(defined("Objects.parentID")))
		AssociateObject2Parents(objects)
	end()

	addObjectID()
	//CalcFeatures()

	Set(index=tbl(TimePoint=create("vector", 0, length, time).vector,StackNum=create("vector", 0, length, stack).vector,FieldNum=create("vector", 0, length, field).vector,ObjectType=create("vector", 13, length, ObjectType).vector,ObjectID=objects.ObjectID,ParentType=objects.parentType,ParentID=objects.ParentID))
	deleteAttr(parentType)
	deleteAttr(ParentID)
	Set(ObjectFeatureTable=Objectlist2Table().table)
	//AppendTable(other=TableMerge(index,ObjectFeatureTable,"ObjectID").table|FeaturesTable=table)
	AccumulateTables(table)
	AccumulateTables(TableMerge(index,ObjectFeatureTable,"ObjectID").table)
	CreateAccumulatedTable(|FeaturesTable=table)
	delete(_accutbl)
}

proc addObjectID(
	objectlist objects inout "Objelist to wich the ObjectID attribute should be added",
	)
{
	if(Not(defined("objects.ObjectID")))
		if(Not(defined("objects.masscentre")))
			CalcMassCentre()
		end()
		CalcStat("Max",AttrName="ObjectID", image=objects.index,stencil=masscentre)
	end()
}
proc AssociateObject2Parents(
	objectlist objects in "Objectlist containing the objects to map",
	objectlist objects out "Objectlist containing the mapping to their parents. Two new subkeys: \"ParentObjectTpe\"=Name of the parent object, \"ParentObjectID\"=ID of the parent object",
	Container parentObjects=none in "Container of objetcList, corresponding to the parents to wich \"Objects\" should be mapped. Use cnt(a=objectlList1,b=objectlist2,...)",
	Vector parentNames=none in "Vector containing the names for the parents in the order for which the mapping should be done. Objects with name at a  higher Index contain objects with lower index (ex. Nuclei should have a lower index than WholeCells). use vec(\"name1\",\"name2\",...)",
) object list attribute creation "Adds to the object the linkage to parent objects. The object will be map to the parent objeclits with name parentNames[0], then to parentNames[1],etc. If no Parent object is provided or parentObjectsName a",
{
	//Add the proper columns to empty objects
	if(objects.count==0)
		Set(objects.ObjectID=vec())
		Set(objects.ParentType=vec())
		Set(objects.ParentID=vec())
		return()
	end()
	set(oldData="")
	if(not(Defined("parentObjects")))
		Set(objects.ParentType=create("vector", 13, objects.count, "WholeWell").vector)
		Set(objects.ParentID=create("vector", 0, objects.count, 1).vector)
		return()
	end()
	if(Not(Defined("parentNames")))
		set(parentNames=parentObjects.keys)
	end()

	addObjectID()

	if(Not(defined("objects.masscentre")))
		CalcMassCentre()
	end()
	foreach(parentNames,"name")
		if(defined("ParentObjects[name]"))
			set(parent=ParentObjects[name])
			try()
				if(parent.class=="objectList"||parent.class=="compositobjectlist")
					if(parent.class=="compositobjectlist")
						compositObjectVerifier(parent)
						set(parent=parent.fullSet)
					end()
					containedObjects(parent,objects,objectsStencil="massCentre")
					CalcStat("Max",AttrName="ParentID", image=parent.body.image, stencil=masscentre)
					Set(objects.ParentType=create("vector", 13, objects.count, name).vector)
					combineMemBlocks(oldData, objects,DeleteGeometry=false,KeepAutoRecalc=true|oldData=newData)
					rename(objects=remainder)
				end()
			end()
		end()
	end()
	
	//Associating the rest of the objects with wholeWell.
	if(Defined("objects"))
	if(objects.count>0)
		Set(objects.ParentType=create("vector", 13, objects.count, "WholeWell").vector)
		Set(objects.ParentID=create("vector", 0, objects.count, 1).vector)
		combineMemBlocks(oldData, objects,DeleteGeometry=false,KeepAutoRecalc=true|oldData=newData)
	end()
	end()
	rename(objects=oldData)
}

proc AssociateObject2Phenotypes(
	objectlist objects in "Objectlist containing the objects to map",
	objectlist objects out "Objectlist containing the mapping to the phenotype. The subkey ending with \"Phenotype\" is added to the object list",
	Container Phenotypes=none in "Container of objetcList, corresponding to the different subpopulation. These population are usually obtained via objectFilter or filter my object. Use cnt(objectlList1,objectlist2,...) to assemble the different subpopulation in a single container.",
	String PhenotypeName="" in "Name of the phenotype entered. This value is added in the key returned. Ex. if PhenotypeName=\"G0G1\" the object returned will contain a \"G0G1_Phenotype\" attribute. Do not use spaces or special caracters in this name.",
	String phenotypePrefix="" in "Prefix to add in front of the name of the objectlist provided in Phenotypes.",
	String phenotypeSufix="" in "Suffix to add after the name of the objectlist provided in Phenotypes.",
) object list attribute creation "Adds to an object list a name for the phenotype. For isntance objects which have a positive intensity will be labeled as such.",
{
	set(PhenotypeName=PhenotypeName&"_Phenotypes")
	set(oldData="")
	Set(objects[PhenotypeName]=create("vector", 13, objects.count, "").vector)
	if(not(Defined("Phenotypes")))
		return()
	end()
	if(Not(defined("objects.masscentre")))
		CalcMassCentre()
	end()
	foreach(Phenotypes.keys,"name")
		if(defined("Phenotypes[name]"))
			set(Phenotypes=Phenotypes[name])
			if(Phenotypes.class=="objectList")
				containedObjects(Phenotypes,objects,objectsStencil="massCentre")
				CalcStat("Max",AttrName="PhenotypesID", image=Phenotypes.body.image, stencil=masscentre)
				Set(objects[PhenotypeName]=objects[PhenotypeName] & create("vector", 13, objects.count,phenotypePrefix & name & phenotypeSufix & "|").vector)
				combineMemBlocks(oldData, objects,DeleteGeometry=false,KeepAutoRecalc=true|oldData=newData)
				rename(objects=remainder)
			end()
		end()
	end()
	if(Defined("objects"))
	if(objects.count>0)
		Set(objects[PhenotypeName]=objects[PhenotypeName]&create("vector", 13, objects.count, "NA").vector)
	end()
	end()
	rename(objects=oldData)
}

proc compositObjectVerifier(
	container compositObject in "Conatiner to validate as \"compositobjectlist\"",
	boolean isCompositObject out "Value which indicates whether the object provided is a composit object or not",
) [hidden] "Technical procedure, which asses wether the container provided is a valid \"compositobjectlist\""
{
	set(isCompositObject=false)
	if(compositObject.class!="compositobjectlist")
		warning("The object sent for evaluation is not an ObjectList")
		return()
	end()
	if(Not(defined("compositObject.FullSet")))
		Error("A composite objectlist should contain an objectlist named \"FullSet\".")
	end()
	if(Not(defined("compositObject.count")))
		Error("A composite objectlist should contain a table named \"count\".")
	end()
	if(typeOf(compositObject)!="memblock")
		Error("A composite objectlist should contain a table named \"count\".")
	end()
	if(compositObject.count.class!="table")
		Error("A composite objectlist should contain a table named \"count\".")
	end()
	if(Not(defined("compositObject.count.FullSet")))
		Error("The count table of an object list must conatin a key named \"FullSet\".")
	end()
	if(compositObject.count.length<1)
		Error("The count table of an object list must have a size >=1.")
	end()
	set(isCompositObject=true)
}

proc buildCompositObject(
	table ruleSet in "Rulset is a table which allows to split the object provided into multiple componnents to generate a composite Object. A rule set should have the 3 following columns: \"Formula\" which provide the information to split the object. You can enter multiple formulas seprated by \";\" this will return a list of objects which satisfies all of the formulas provided. The second column \"PopulationName\", gives the name of the objects which match the formula. Finally, \"RemainingPolulationName\" contains the name for the remaining objects. If left blank this population is discarded",
	objectlist objects in "Objectlist conating all of the objects from which are derived the objects contained in the container \"compositObject\".",
	container compositObject out "Container containing a list of objects that should be turned into a composit object",
	bool ShowIllustrations=true in "Yes - Output illustrations are depicted. No- Output illustrations are not shown.",
) object list manipulations "Makes a composit objects which contains different subpopulation of the original object."
{
	Set(compositObject=cnt())
	set(compositObject.class="compositobjectlist")
	set(compositObject.FullSet=objects)
	set(compositObject.RuleSet=ruleSet)
	set(compositObject.count=tbl(FullSet=vec(objects.count)))


	if(ruleSet.length<3 || not(Defined("ruleSet.Formula") && Defined("ruleSet.PopulationName") && Defined("ruleSet.RemainingPolulationName")))
		Error("Cannot build a compositObject list, because the ruleSet provided is invalid.")
	end()
	foreach(0..ruleSet.lenght-1,"ruleIndex")
		set(objects=compositObject.FullSet)
		Set(formulas=SplitString(ruleSet.formula[ruleIndex],";"))
		if(formulas.lengt<1)
			Warning("No formula(s) provided at index " & ruleIndex &" of the ruleSet. Proceeding to the next ruleSet")
		end()
		foreach(0..formulas.length-1)
			try()
				SplitMyObjects(formula[i],objects=objects)
			Catch_Error()
				warning("One of the formula:\""&formulas[i]&"\" is not valid and returned the following error: "&catch_message&". The ruleSet at index " & ruleIndex &" is therefore invalid. proc eeding to the next formula in the ruleSet.")
				break()
			end()
		end()
		Set(name=reQuote(ruleSet.PopulationName[ruleIndex]).text)
		Set(compositObject[name]=objects)
		set(compositObject.count[name]=vec(objects.count))
		Set(name=reQuote(ruleSet.RemainingPolulationName[ruleIndex]).text)
		if(name!="")
			Set(compositObject[name]=remainder)
			Set(compositObject.count[name]=vec(remainder.count))
		end()
	end()
}

proc assembleCompositObject(
	container compositObject inout "Container containing a list of objects that should be turned into a composit object",
	objectlist objects in "Objectlist conating all of the objects from which are derived the objects contained in the container \"compositObject\"."
) object list manipulations "Makes a composit objects which contains different subpopulation of the original object."
{
	set(count=tbl(FullSet=vec(objects.count)))
	foreach(compositObject.keys,"keyName")
			set(count[keyName]=vec(compositObject[keyName].count))
	end()
	set(compositObject.count=count)
	set(compositObject.FullSet=objects)
	set(compositObject.class="compositobjectlist")
}

proc normalizeObjects(
	objectlist objects out "Objects normalized.",
	double NormalizationFactor=3 in "Normalization factor to apply. The lower the value, the more objects are removed.If set \"0\", the normalization is not run.",
	string featureToNormalize="" in "Normalize the selected feature, if selected featureToNormalize=\"\", normalize on a default set of features (Area, Roundness, Perimeter, Perimeter/Area, Width, Length, Width/Length, and Intenisty if an image is provided). If a value is provided, the object should conatin that feature.",
	image image=none in "Image to use if a normalization on the image intensity is desired. If not provided, no intensity is returned",
	String stencil="body" noquote in "Stencil to use with the image provided. If set to \"\", use \"body\"",
	boolean showIllustrations=true in "YES- Output illustrations are depicted. No- Output illustrations are not shown.",
	objectlist objects in "Objects to be normalized",
	boolean keepCaluclatedAttributes=false in "Indicate whether the attributes calculated and used to normalize the objectlist should be kept or not.",
)object list manipulations "Remove objects which physical properties do not fall within \"NormalizationFactor\" Standard deviation away from the mean value."
{
	if(NormalizationFactor==0)
		return()
	end()
	if(defined("image"))
		if(stencil=="")
			Set(stencil="body")
		end()
		if(! defined("objects[stencil]") || ! defined("objects[stencil].@type"))
			Error("The stencil Provided: "&stencil&" does not exist")
		end()
		if(objects[stencil].type!="stencil")
			Error("The stencil Provided: "&stencil&" is not a Stencil")
		end()
		CalcStat("Mean",AttrName="Temp_Intensity", image=image,stencil=objects[stencil])
		Set(TopCutOffIntensity=objects.Temp_Intensity.mean+NormalizationFactor*objects.Temp_Intensity.stdDev)
		Set(BotCutOffIntensity=objects.Temp_Intensity.mean-NormalizationFactor*objects.Temp_Intensity.stdDev)
		ObjectFilter(Temp_Intensity<TopCutOffIntensity,objects=objects)
		ObjectFilter(Temp_Intensity>BotCutOffIntensity,objects=objects)
		deleteAttr(Temp_Intensity)
	else()
		blank(objects.imagewidth,objects.imageheight)
	end()

	if(featureToNormalize!="")
		if(at("@",featureToNormalize,1)!=1)
			Set(featureToNormalize=quote(featureToNormalize,"Name").quoted)
		end()
		if(defined("objects[featureToNormalize]"))
			Set(TopCutOff=objects[featureToNormalize].mean+NormalizationFactor*objects[featureToNormalize].stdDev)
			Set(BotCutOff=objects[featureToNormalize].mean-NormalizationFactor*objects[featureToNormalize].stdDev)
			Set(formula=featureToNormalize&"<"&TopCutOff)
			ObjectFilter(""&Formula,objects=objects)
			Set(formula=featureToNormalize&">"&BotCutOff)
			ObjectFilter(""&Formula,objects=objects)
		else()
			Warning(" Nothing to Normalize. The feature to normalize: "&featureToNormalize &" does not exist. Make sure that quotation is correct.")
		end()
		if(showIllustrations)
			if(Not(defined("objects.border")))
				calcBorder()
			end()
			ImageView(objects.border,image=image,Title="Remaining objects after Normalization", label="NormalizedObject")
		end()
		return()
	end()

	//**********************
	//** Normalization of different morphological data
	//**********************

	Set(ObjectsIni=objects)

	if(Not(defined("objects.area")))
		calcattr(Area,AutoRecalc=false)
	end()
	Set(TopCutOffArea=objects.area.mean+NormalizationFactor*objects.area.stdDev)
	Set(BotCutOffArea=objects.area.mean-NormalizationFactor*objects.area.stdDev)

	if(Not(defined("objects.perimeter")))
		calcBorder()
		CalcArea(border,AutoRecalc=false)
		RenameAttr(Perimeter=border_area)
	end()
	Set(TopCutOffPerimeter=objects.Perimeter.mean+NormalizationFactor*objects.Perimeter.stdDev)
	Set(BotCutOffPerimeter=objects.Perimeter.mean-NormalizationFactor*objects.Perimeter.stdDev)

	setAttr(ratio_Perimeter_To_Area, perimeter/area)
	Set(TopCutOffPeriArea=objects.ratio_Perimeter_To_Area.mean+NormalizationFactor*objects.ratio_Perimeter_To_Area.stdDev)
	Set(BotCutOffPeriArea=objects.ratio_Perimeter_To_Area.mean-NormalizationFactor*objects.ratio_Perimeter_To_Area.stdDev)

	if(Not(defined("objects.half_width"))||Not(defined("objects.full_length")))
		CalcWidthLengthSafe(factor=0)
	end()
	Set(TopCutOffLength=objects.Full_Length.mean+NormalizationFactor*objects.Full_Length.stdDev)
	Set(BotCutOffLength=objects.Full_Length.mean-NormalizationFactor*objects.Full_Length.stdDev)
	Set(TopCutOffWidth=objects.Half_width.mean+NormalizationFactor*objects.Half_width.stdDev)
	Set(BotCutOffWidth=objects.Half_width.mean-NormalizationFactor*objects.Half_width.stdDev)

	setAttr(ratio_Half_width_To_Full_Length, perimeter/area)
	Set(TopCutOffWidthLength=objects.ratio_Half_width_To_Full_Length.mean+NormalizationFactor*objects.ratio_Half_width_To_Full_Length.stdDev)
	Set(BotCutOffWidthLength=objects.ratio_Half_width_To_Full_Length.mean-NormalizationFactor*objects.ratio_Half_width_To_Full_Length.stdDev)

	if(Not(defined("objects.roundness")))
		calcattr(Roundness,AutoRecalc=false)
	end()
	Set(TopCutOffRoundness=objects.Roundness.mean+NormalizationFactor*objects.Roundness.stdDev)
	Set(BotCutOffRoundness=objects.Roundness.mean-NormalizationFactor*objects.Roundness.stdDev)

	if(defined("objects.contrast"))
		Set(TopCutOffContrast=objects.contrast.mean+NormalizationFactor*objects.contrast.stdDev)
		Set(BotCutOffContrast=objects.contrast.mean-NormalizationFactor*objects.contrast.stdDev)
		ObjectFilter(contrast<TopCutOffContrast,objects=objects)
		ObjectFilter(contrast>BotCutOffContrast,objects=objects)
	end()

	ObjectFilter(area<TopCutOffArea,objects=objects)
	ObjectFilter(area>BotCutOffArea,objects=objects)

	ObjectFilter(Perimeter<TopCutOffPerimeter,objects=objects)
	ObjectFilter(Perimeter>BotCutOffPerimeter,objects=objects)

	ObjectFilter(ratio_Perimeter_To_Area<TopCutOffPeriArea,objects=objects)
	ObjectFilter(ratio_Perimeter_To_Area>BotCutOffPeriArea,objects=objects)

	ObjectFilter(Full_Length<TopCutOffLength,objects=objects)
	ObjectFilter(Full_Length>BotCutOffLength,objects=objects)

	ObjectFilter(Half_width<TopCutOffWidth,objects=objects)
	ObjectFilter(Half_width>BotCutOffWidth,objects=objects)

	ObjectFilter(ratio_Half_width_To_Full_Length<TopCutOffWidthLength,objects=objects)
	ObjectFilter(ratio_Half_width_To_Full_Length>BotCutOffWidthLength,objects=objects)

	ObjectFilter(Roundness<TopCutOffRoundness,objects=objects)
	ObjectFilter(Roundness>BotCutOffRoundness,objects=objects)

	if(!keepCaluclatedAttributes)
		CalcStat("Mean",AttrName="Temp_Filtering", image=objects.index,objects=objectsIni)
		ObjectFilter(Temp_Filtering>0)
		DeleteAttr(Temp_Filtering)
	end()
	if(showIllustrations)
		if(Not(defined("objects.border")))
			calcBorder()
		end()
		ImageView(objects.border,image=image,Title="Remaining objects after Normalization", label="NormalizedObject")
	end()
}