//#############################################################################################
//# Acapella Script and procedures Collection: A collection of Acapella based scripts
//# and libraries.
//#
//# Please acknowledge the author(s)/contributor(s) for making use of these scripts and library.
//# Authors:
//#   * Ghislain M.C. Bonamy
//#   * Genomics Institute of the Novartis Research Foundation (GNF), San Diego, CA 92122
//#   * www.gnf.org
//#
//# You can obtain the latest version of this software at: http://code.google.com/p/operahci/
//#
//# This program is free software; you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation; either version 2 of the License, or
//# (at your option) any later version.
//#
//# This program is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with this program; if not, write to the Free Software
//# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//# or go to: http://www.apache.org/licenses/
//#############################################################################################

//*********************************************************************************************
//*
//* This library defines a set of procedures used to work with cellular features/textures.
//*
//*********************************************************************************************


proc CalcFractionEdgeContact(
	string attrName="" in "The name of the created attribute. Use \"\" if you want to have the attrName automatically generated (ex. \"Border_DegreeImageEdgeContact\")",
	string stencil="Border"  in "Specifies location of object pixels. This stencil should be of type border (ie. not filled)",
	ObjectList objects localcontext  in "The object list containing the stencil for which the degree of contact with the image edge is measured and containing the new attribute",
	ObjectList objects out "The object list containing the newly created attribute.",
) Object list attribute creation, Features "Calculates a feature measuring the degree of overlap of a \"border-like\" stencil with the image edge."
{
	if(! Defined("objects."&stencil))
		Error("The stencil selected: \""&Stencil&"\" does not exist in the object provided.")
	end()

	Rename(objectsIni=objects)

	Stencil2Objects(objectsIni[stencil])
	CalcBorder()
	CalcArea(Border)
	Set(width=objects.imagewidth,height=objects.imageheight)
	Blank()
	RectMask(2,2,width-2,height-2,image=image,Inverted=true)
	CalcStat("Mean",stencil=Border,AttrName="Contact",Image=Mask)
	set(attrName=iif(attrName=="",iif(stencil=="Body","",stencil&"_")&"DegreeImageEdgeContact",attrName))

	SetAttr(&AttrName,objects.Contact/objects.Border_Area,objects=objectsIni)
}

proc getFeatures(
	Objectlist objects in "Object list containing the features to calculate. Make sure that the Objectlist only contains stencil which you wish to use for intensity measurements.",
	Vector images=none in  "Container containing the images for each channels (for a given stack & field). These images are used to calculate the object intensity-based feature for each objects. If no images are provided, or if the images is an empty vector, these features are not returned. Images should have the form images[channel].image & images[channel].name. This can be obtained after using the ImagesInit() module and selecting a channel stack ex: set(images=ImagesInit().images[field][stack]).",
	Objectlist objects out "Object list containing the newly calculated features.",
	Container parentObjects=none in "Container with the different objectLists to use as parents from objects. Ex, for spots, a container containing nuclei and/or whole Cells, would allow to classify spots to the correct parent. If nothing is provided the object is associated to \"WholeWell\". Use Pack(parentObjects,...) to generate this. Ex: pack(parentObjects,Nuclei,WholeCells).",
	Vector parentNames=none in "Vector containing the names for the parents in the order for which the mapping should be done. Objects with name at a  higher Index contain objects with lower index (ex. Nuclei should have a lower index than WholeCells). use vec(\"name1\",\"name2\",...)"
)object list attribute creation, Feature, Texture "Adds to an object all of the features that can be extracted. Generates the inputs necessary. Cf. CalcFeaturesInner()"
{
	CalcFeaturesInputs()
	CalcFeatures()
}

proc CalcFeaturesInputs(

	boolean CalcMorphologyFeatures=true out "Indicate whether or not to collect morphology-based features (length, area etc.). This will moderately impact runtime.",
	boolean CalcIntensityInfo=true out "Indicate whether or not to collect intensity-based features (Intensity, CV, etc.). This will moderately impact runtime.",
	boolean CalcCorrelationFeatures=false out "Indicate whether or not to collect image correlation features (Perason Correlation). This will significantly impact runtime.",

	boolean CalcTASFeatures out "Indicate whether or not you wish to collect TAS (Threshold Adjacency Statistics) textural feature. Threshold Adjacency Statistics have been introduced by Nicholas Hamilton et al. (2007). Using a lower and an upper threshold, a mask is calculated representing those pixels that satisfy the given threshold conditions. Thereafter, each pixel is given a score according to the number of its neighbor pixels under the mask. A TAS feature is the relative number of pixels with the given score. TAS features can be calculated very fast.",
	double TASbracket out "Braket Factor : The value used will provide varying cut-offs depending on the normalization method selected. This value, used in conjunction with the mean intensity of an object allows to establish 3 different thresholds. For a given object, the absolute thresholds are then calculated with: \"(mean object intensity)*(1+-bracket)\", when NormalizationMethod=\"Mean\"; \"(mean object intensity) +/- bracket x (StdDev object intensity)\" when NormalizationMethod=\"zScore\"; \"(mean object intensity) +/- bracket when\" when  NormalizationMethod=\"None\". This value should should be >0 when NormalizationMethod=\"None\" or \"zScore\" and be set between 0 and 1 when NormalizationMethod=\"Mean\".",
	string TASnormalization out "Indicates which normalization should be used to normalize the object intensity. The following methods are accepted: \"None\" in which case no normalization is provided and the bracket refers to raw pixel values; \"Mean\", in which case the values are normalized by the mean value of the object and the bracket then refers to a fold intensity above and bellow the mean value; \"zScore\" in which case each pixels is converted into a number of StdDev above and bellow the mean value and a Z-score reflects a cut-off in this scale.",

	boolean CalcSERFeatures out "Indicate whether or not you wish to collect SER (Spots, Edges and Ridges) textural feature. SER features are a set of eight properties that are sensitive to different characteristic intensity patterns as described by the property name. This feature will significantly slow your analysis.",
	vector SERscale out "Scale parameter for SER texture filtering.",
	string SERnormalization out "SER normalization methods. Select between unnormalized, kernel, regional.",

	boolean CalcGaborFeatures out "Indicate whether or not you wish to collect SER (Spots, Edges and Ridges) textural feature. SER features are a set of eight properties that are sensitive to different characteristic intensity patterns as described by the property name. This feature will significantly slow your analysis.",
	double GaborMinScale out "The lowest scale value used in Gabor features calculation. The value of \"Scale/Wavevelenght\" should be >0.25.",
	double GaborMinWavelength out "The lowest wavelength value used in Gabor features calculation. The value of \"Scale/Wavevelenght\" should be >0.25.",
	vector GaborScaleFactors out "Values by which MinScale is multiplied for Gabor features calculation. The value of \"Scale/Wavevelenght\" should be >0.25.",
	vector GaborWavelengthFactors out "Values by which MinWavelength is multiplied for Gabor features calculation. The value of \"Scale/Wavevelenght\" should be >0.25.",
	int GaborAngleCount out "Number of orientations. Reasonable values are between 6 and 16",
	string GaborNormalization="regional" out "Regional - denominator is mean intensity of each object; external - denominator is a pre-calculated norm-attribute; unnormalized is also an option",

	boolean CalcHaralickFeatures out "Indicate whether or not you wish to collect Haralick textural feature. Haralick feature is a set of eight properties that are sensitive to different characteristic intensity patterns as described by the property name. This feature will significantly slow your analysis.",
	int HaralickDistance out "Distance between Haralick pixel pairs. NB Fractional distance values will be rounded to integers",

	boolean CalcFourrierDescriptors=false out "Indicate whether or not to calculate the Fourier Descriptors of a cell.",
	int NumberOfFourierDescriptors out "Number of Fourier_Descriptors to output.",
	int StepSize out "The size of the step.",
	int NumberSegments out "The number of segments when partitioning the centroid.",
	string ShapeSignatureChoice out "Name of the shape signature chosen by the user"

)[Hidden] object list attribute creation, Features, Textures "Inputs required for the CalcFeatures Module."
{

	input(CalcMorphologyFeatures, true, "Measure Morphology Information:Cell Features", "b", "Indicate whether or not you wish to collect morphology-based features (length, area etc.). This will moderately impact runtime.")
	input(CalcIntensityInfo, true, "Measure Intensity Information:Cell Features", "b", "Indicate whether or not you wish to collect intensity-based features (Intensity, CV, etc.). This will moderately impact runtime.")
	input(CalcCorrelationFeatures, false, "Measure Image Correlation:Cell Features", "b", "Indicate whether or not you wish to collect image correlation features (Perason Correlation). This will significantly impact runtime.")


	input(CalcTASFeatures, false , "Measure TAS Texture:Cell Features", "b", "Indicate whether or not you wish to collect TAS (Threshold Adjacency Statistics) textural feature. Threshold Adjacency Statistics have been introduced by Nicholas Hamilton et al. (2007). Using a lower and an upper threshold, a mask is calculated representing those pixels that satisfy the given threshold conditions. Thereafter, each pixel is given a score according to the number of its neighbor pixels under the mask. A TAS feature is the relative number of pixels with the given score. TAS features can be calculated very fast.")
	input(TASbracket, 0.2, "TAS Texture Braket:Cell Features", "d", "Bracket Factor : The value used will provide varying cut-offs depending on the normalization method selected. Use 0 to try test different values (for assay development). This value, is used in conjunction with the mean intensity of an object allows to establish 3 different thresholds. For a given object, the absolute thresholds are then calculated with: \"(mean object intensity)*(1+-bracket)\", when NormalizationMethod=\"Mean\"; \"(mean object intensity) +/- bracket x (StdDev object intensity)\" when NormalizationMethod=\"zScore\"; \"(mean object intensity) +/- bracket when\" when  NormalizationMethod=\"None\". This value should should be >0 when NormalizationMethod=\"None\" or \"zScore\" and be set between 0 and 1 when NormalizationMethod=\"Mean\". Allowed range: 0..100, step 0.05.")
	input(TASnormalization, "Mean", "TAS Texture NormMode:Cell Features", "b", "Indicates which normalization should be used to normalize the object intensity. The following methods are accepted: \"None\" in which case no normalization is provided and the bracket refers to raw pixel values; \"Mean\", in which case the values are normalized by the mean value of the object and the bracket then refers to a fold intensity above and bellow the mean value; \"zScore\" in which case each pixels is converted into a number of StdDev above and bellow the mean value and a Z-score reflects a cut-off in this scale. Allowed values:  \"None\", \"Mean\", \"zScore\".")

	input(CalcSERFeatures, false , "Measure SER Texture:Cell Features", "b", "Indicate whether or not you wish to collect SER (Spots, Edges and Ridges) textural feature. SER features are a set of eight properties that are sensitive to different characteristic intensity patterns as described by the property name. This feature will significantly slow your analysis.")
	input(SERscale,"0.5", "SER Texture Scale:Cell Features", "d", "Comma separated list of scale parameters for SER texture filtering. use '0' to test multiple values. Allowed range: 0..50, step 0.05")
	if(SERscale==0)
		Set(SERSCale=vec(0,0.25,0.5,1,1.5,2,3,4,6,12))
	else()
		set(SERscale=vec(SERScale))
	end()
	input(SERnormalization, "regional", "SER Texture NormMode:Cell Features", "s", "Normalization method used for SER texture.  Allowed values:  \"regional\", \"unnormalized\", \"kernel\".")

	input(CalcGaborFeatures, false , "Measure Gabor Texture:Cell Features", "b", "Indicate whether or not you wish to collect Gabor textural feature. Gabor features are a set of two selected features that are generated by Gabor filtering. These properties are based on the analysis of spatial repetitions in the texture pattern. A number of parameters need to be adjusted to specify the characteristic \"wavelength\" and \"scale\" of the features to be identified.  is a set of eight properties that are sensitive to different characteristic intensity patterns as described by the property name. This feature will significantly slow your analysis.")
	input(GaborMinScale, 2, "Gabor Min Scale:Cell Features", "d", "The lowest scale value used in Gabor features calculation. The value of \"Scale/Wavevelenght\" should be >0.25. Allowed range: 0..100, step 0.05.")
	input(GaborMinWavelength, 2.5, "Gabor Min Wavelength:Cell Features", "d", "The lowest wavelength value used in Gabor features calculation. The value of \"Scale/Wavevelenght\" should be >0.25. Allowed range: 0..100, step 0.05.")
	input(GaborScaleFactor, "1", "Gabor Scale Factor:Cell Features", "d", "Comma delimited values by which MinScale is multiplied for Gabor features calculation. Use '0' to test multiple values. The value of \"Scale/Wavevelenght\" should be >0.25. Allowed range: 0..100, step 0.5.")
	if(GaborScaleFactor==0)
		set(GaborScaleFactors=vec(0.5,1,2,4,8,16))
	else()
		set(GaborScaleFactors=GaborScaleFactor)
	end()
	input(GaborWavelengthFactor, "1", "Gabor Wavelength Factor:Cell Features", "d", "Comma delimited values by which MinWavelength is multiplied for Gabor features calculation. Use '0' to test multiple values. The value of \"Scale/Wavevelenght\" should be >0.25. Allowed range: 0..100, step 0.5.")
	if(GaborWavelengthFactor==0)
		set(GaborWavelengthFactors=vec(0.5,1,2,4,8,16))
	else()
		set(GaborWavelengthFactors=GaborWavelengthFactor)
	end()

	input(GaborAngleCount, 8, "Gabor Angle Count:Cell Features", "i", "Number of orientations. Reasonable values are between 6 and 16. Allowed range: 4..20, step 1.")

	input(GaborNormalization, "regional", "Gabor Texture NormMode:Cell Features", "s", "Normalization method used for Gabor texture.  Allowed values:  \"regional\", \"unnormalized\", \"external\", \"kernel\".")

	input(CalcHaralickFeatures, false , "Measure Haralick Texture:Cell Features", "b", "Indicate whether or not you wish to collect Haralick textural feature. Haralick feature is a set of eight properties that are sensitive to different characteristic intensity patterns as described by the property name. This feature will significantly slow your analysis.")
	input(HaralickDistance, 1, "Haralick Distance:Cell Features", "i", "Distance between Haralick pixel pairs. Use 0 to try test different values (for assay development). Allowed range: 0..100, step 1.")


	input(CalcFourrierDescriptors, false, "Measure the Fourier Descriptors of a cell:Cell Features", "b", "Indicate whether or not to calculate the Fourier Descriptors of a cell.")
	input(ShapeSignatureChoice,"ComplexCoordinateFunction", "Shape Signature:Cell Features", "s", "Name of the shape signature chosen by the user. Allowed values: \"ComplexCoordinateFunction\", \"CentroidDistanceFunction\", \"AreaFunction\", ,\"CumulativeAngularFunction\", \"CurvatureSignature\",\"PolarCoordinateFunction\", \"AngularRadiusFunction\", \"NormalizedComplexCoordinatesFunction\", \"AffineInvariantMethod2009\", \"FarthestPointDistanceFunction\", \"ArcHeightFunction\", \"SegmentedCentroidDistanceFunction\",\"Testing\"")
	//CF. FourierDescriptorsSelection_input to make changes and copy back
	input(NumberOfFourierDescriptors, 4, "Number of Fourier Descriptors:Cell Features", "i", "Indicate the number of Fourier_Descriptors to output. Allowed range: 1..1024, step 1.")
	input(StepSize, 1, "Step Size:Cell Features", "i", "Applicable to Shape Signature \"CumulativeAngularFunction\",\"CurvatureSignature\" and \"AngularRadiusFunction\" for calculating of Delta(t) = atan((y(t)-y(t-w)) / (x(t)-x(t-w))), for t=0,1,...,N-1 where (x(t),y(t)) is the shape boundary coordinates, N is the number of boundary points and w is the input step size. Allowed range: 1..10, step 1.")
	input(NumberSegments, 2, "Number of Segments:Cell Features", "i", "Applicable to Shape Signature \"SegmentedCentroidDistanceFunction\" to give the number of segments when partitioning the centroid. Allowed range: 1..4, step 1.")
}

proc CalcFeatures(
	Objectlist objects in "Object list containing the features to calculate. Make sure that the Objectlist only contains stencil which you wish to use for intensity measurements.",
	Vector images=none in  "Container containing the images for each channels (for a given stack & field). These images are used to calculate the object intensity-based feature for each objects. If no images are provided, or if the images is an empty vector, these features are not returned. Images should have the form images[channel].image & images[chnanel].name. This can be obtained after using the ImagesInit() module and selecting a channel stack ex: set(images=ImagesInit().images[field][stack]).",
	Objectlist objects out "Object list containing the newly calculated features.",
	Container parentObjects=none in "Container with the different objectLists to use as parents from objects. Ex, for spots, a container containing nuclei and/or whole Cells, would allow to classify spots to the correct parent. If nothing is provided the object is associated to \"WholeWell\". Use Pack(parentObjects,...) to generate this. Ex: pack(parentObjects, Nuclei, WholeCells).",
	Vector parentNames=none in "Vector containing the names for the parents in the order for which the mapping should be done. Objects with name at a  higher Index are physical containers for objects with lower index (ex. Nuclei should have a lower index than WholeCells). use vec(\"name1\",\"name2\",...)",


	boolean CalcMorphologyFeatures=true in "Indicate whether or not you wish to collect morphology-based features (lenght, area etc.). This will moderatly impact runtime.",
	boolean CalcIntensityInfo=true in "Indicate whether or not you wish to collect intensity-based features (Intensity, CV, etc.). This will moderatly impact runtime.",
	boolean CalcCorrelationFeatures=false in "Indicate whether or not you wish to collect image correlation features (Perason Correlation). This will significantly impact runtime.",

	boolean CalcTASFeatures=false in "Indicates whether or not you wish to collect TAS (Threshold Adjacency Statistics) textural feature. Threshold Adjacency Statistics have been introduced by Nicholas Hamilton et al. (2007). Using a lower and an upper threshold, a mask is calculated representing those pixels that satisfy the given threshold conditions. Thereafter, each pixel is given a score according to the number of its neighbor pixels under the mask. A TAS feature is the relative number of pixels with the given score. TAS features can be calculated very fast.",
	double TASbracket=0.2 in "Braket Factor : The value used will provide varying cutt-offs depending on the normalization method selected. Use 0 to try test different values (for assay development). This value, used in conjunction with the mean intensity of an object allows to establish 3 different thresholds. For a given object, the absolute thresholds are then calculated with: \"(mean object intensity)*(1+-bracket)\", when NormalizationMethod=\"Mean\"; \"(mean object intensity) +/- bracket x (StdDev object intensity)\" when NormalizationMethod=\"zScore\"; \"(mean object intensity) +/- bracketwhen\" when  NormalizationMethod=\"None\". This value should should be >0 when NormalizationMethod=\"None\" or \"zScore\" and be set between 0 and 1 when NormalizationMethod=\"Mean\".",
	string TASNormalization="Mean" in "Indicates which normalization should be used to normalize the object intensity. The following methods are accepetd: \"None\" in which case no normalization is provided and the bracket refferes to raw pixel values; \"Mean\", in which case the values are normalized by the mean value of the object and the bracket then reffers to a fold intensity above and bellow the mean value; \"zScore\" in which case each pixels is converted into a number of StdDev above and bellow the mean value and a Z-score reflects a cutt-off in this scale.",

	boolean CalcSERFeatures=false in "Indicate whether or not you wish to collect SER (Spots, Edges and Ridges) textural feature. SER features are a set of eight properties that are sensitive to different characteristic intensity patterns as described by the property name. This feature will significantly slow your analysis.",
	vector SERscale=vec(1) in "Vector of scale parameters for SER texture filtering.",
	string SERnormalization="regional" in "SER normalization methods. Select between unnormalized, kernel, regional.",

	boolean CalcGaborFeatures=false in "Indicate whether or not you wish to collect SER (Spots, Edges and Ridges) textural feature. SER features are a set of eight properties that are sensitive to different characteristic intensity patterns as described by the property name. This feature will significantly slow your analysis.",
	double GaborMinScale=2.0  in "The lowest scale value used in Gabor features calculation. The value of \"Scale/Wavevelenght\" should be >0.25.",
	double GaborMinWavelength=2.5  in "The lowest wavelength value used in Gabor features calculation. The value of \"Scale/Wavevelenght\" should be >0.25.",
	vector GaborScaleFactors=vec(1)  in "Values by which MinScale is multiplied for Gabor features calculation. The value of \"Scale/Wavevelenght\" should be >0.25.",
	vector GaborWavelengthFactors=vec(1)  in "Values by which MinWavelength is multiplied for Gabor features calculation. The value of \"Scale/Wavevelenght\" should be >0.25.",
	int GaborAngleCount=8  in "Number of orientations. Reasonable values are between 6 and 16",

	boolean CalcHaralickFeatures=false in "Indicate whether or not you wish to collect Haralick textural feature. Haralick feature is a set of eight properties that are sensitive to different characteristic intensity patterns as described by the property name. This feature will significantly slow your analysis.",
	int HaralickDistance=1 in "Distance between Haralick pixel pairs. Use 0 to try test different values (for assay development). NB Fractional distance values will be rounded to integers.",

	boolean CalcFourrierDescriptors=false in "Inidcate whether Fourier shape descriptors should be measured or not",
	int NumberOfFourierDescriptors in "Number of Fourier_Descriptors to output.",
	int StepSize in "The size of the step",
	int NumberSegments in "The number of segments when partitioning the centroid.",
	string ShapeSignatureChoice in "Name of the shape signature chosen by the user"

) object list attribute creation, Feature, Texture "Adds to an object all of the features that can be extracted."
{
	AssociateObject2Parents(objects)
	addObjectID()
	
	if(CalcMorphologyFeatures)
		if(Not(defined("objects.area")))
			CalcArea()
		end()
		RenameAttr(Area=area)

		if(Not(defined("objects.border")))
			CalcBorder()
			RenameAttr(Border=border)
		end()
		CalcFractionEdgeContact()

		if(Not(defined("objects.perimeter")))
			CalcArea(border)
			RenameAttr(Perimeter=border_area)
		end()

		SetAttr(NearestObjectDistance, objectsDistances().distances)
		if(Not(defined("objects.roundness")))
			CalcAttr(Roundness)
		end()
		if(Not(defined("objects.ratio_Perimeter_To_Area")))
			setAttr(ratio_Perimeter_To_Area, perimeter/area)
		end()
		if(Not(defined("objects.ratio_Width_To_Length")))
			CalcWidthLengthSafe(0) //use the automated object sizing method
			setAttr(ratio_Width_To_Length, 2*half_width/full_length)
		end()
	end()
	
	if(CalcFourrierDescriptors)
		GetFourierDescriptors()
	end()

	set(CalcTextureFeatures=CalcTASFeatures||CalcSERFeatures||CalcGaborFeatures||CalcHaralickFeatures)

	if(defined("images") && (CalcIntensityInfo ||CalcCorrelationFeatures || CalcTextureFeatures))
	if(images.length>0)
		set(numChan=images.length)
		foreach(0..numChan-1)
			if(defined("images["&i&"].name"))
				if(Not(defined("images["&i&"].desc")))
					set(images[i].desc=images[i].name)
				end()
			else()
				sprintf(name,"Chan%02d", i+1)
				set(images[i].desc=name) //pad the number with at last one 0.
			end()
		end()

		foreach(objects.keys,"StencilName")
			//ensure that StencilName is actually a stencil and is neither the Center of mass or a Border.
			if(objects[StencilName].type!="stencil" ||  objects[StencilName].class !="intervalvector" || StencilName=="MassCentre"|| at("border",StencilName,1)>0)
				continue()
			end()

			Set(StencilName=regexReplace(StencilName,"(\b\w|(?<=_)\w)","\u$1").text) //Capitalize word correctly
			Set(objects[StencilName]=objects[StencilName])

			foreach(0..numChan-1)
				set(attrPrefix=StencilName&"_"&images[i].desc)
				set(image=images[i].image)

				if(CalcIntensityInfo)

					CalcMoment(3,central=true, stencil=objects[StencilName])
					set(objects[attrPrefix&"_SkewnessIntensity"]=objects.CentralMoment3)
					deleteAttr(CentralMoment3)
					CalcMoment(4,central=true, stencil=objects[StencilName])
					set(objects[attrPrefix&"_KurosisIntensity"]=objects.CentralMoment4)
					deleteAttr(CentralMoment4)

					Mask(1)
					set(image=image/mask) //Remove all of the values set to 1
					CalcStat("Mean",AttrName=attrPrefix&"_MeanIntensity", image=image,stencil=objects[StencilName])
					CalcStat("Median",AttrName=attrPrefix&"_MedianIntensity", image=image,stencil=objects[StencilName])
					CalcStat("Max",AttrName=attrPrefix&"_MaxIntensity", image=image,stencil=objects[StencilName])
					//CalcStat("quantile",QuantileFraction=0.3085,AttrName=attrPrefix&"_31PercentileIntensity", image=image,stencil=objects[StencilName])
					//CalcStat("quantile",QuantileFraction=0.6915,AttrName=attrPrefix&"_69PercentileIntensity", image=image,stencil=objects[StencilName])
					CalcStat("Sum",AttrName=attrPrefix&"_SumIntensity", image=image,stencil=objects[StencilName])
					CalcStat("StdDev",AttrName=attrPrefix&"_StdDevIntensity", image=image,stencil=objects[StencilName])
					Set(objects[attrPrefix&"_CVIntensity"]=objects[attrPrefix&"_StdDevIntensity"]/objects[attrPrefix&"_MeanIntensity"])
					set(image=images[i].image)

				end()

				if(CalcCorrelationFeatures&&numchan>1&&i<numChan-1)
					foreach(i+1..numChan-1,"nextChan")
						MBF_PearsonsCoefficient(image,images[nextChan].image,objects,stencil=objects[StencilName],AttrName="PearsonsR"|temp=objects)
						set(AttributeName=StencilName&"_"&images[nextChan].desc&"_"&images[i].desc&"_PearsonR")
						set(Objects[AttributeName]=temp.PearsonsR)
					end()
				end()
				if(images[i].purpose.length==0)
					continue()
				end()
				if(CalcTextureFeatures && searchElem("marker",images[i].purpose,0).pos>=0) //only get Texture features for marker channels

					if(CalcTASFeatures)
						if(TASbracket==0)
							set(formula=iif(TASNormalization=="mean","0.1*(x+1)","0.07^x+0.05"))
							tabulate(formula,9)
						else()
							set(result=vec(TASbracket))
						end()
						//Make sure that the vector used has a precision of 1 decimal.
						convElems(result*10,"integer")
						convElems(result/10,"float")
						rename(brackets=result)

						foreach(brackets,"bracket")
							Set(AttrSuffix=iif(brackets.length>1,"Bracket"&bracket,""))
							Texture::CalcTASFeatures(image,bracket,StencilName,NormalizationMethod=TASNormalization,AttrPrefix=attrPrefix, AttrSuffix=AttrSuffix)
						end()
					end()

					if(CalcSERFeatures)
					foreach(SERscale,"scale")
						Set(AttrSuffix=iif(SERscale.length>1,"Scale"&scale,""))
						Texture::CalcSERFeatures(image,scale,StencilName,SERnormalization,AttrPrefix=attrPrefix, AttrSuffix=AttrSuffix)
					end()
					end()

					if(CalcGaborFeatures)
						Texture::CalcGaborFeatures(image,GaborMinScale,GaborMinWavelength,GaborScaleFactors,GaborWavelengthFactors,GaborAngleCount,AttrPrefix=attrPrefix)
					end()

					if(CalcHaralickFeatures)
						if(HaralickDistance==0)
							tabulate("2*x+1",5)
						else()
							set(result=vec(HaralickDistance))
						end()
						convElems(result, "integer")
						rename(distances=result)
						foreach(distances,"distance")
							set(AttrSuffix=iif(distances.length>1,"Distance"&distance,""))
							Texture::CalcHaralickFeatures(image,distance,StencilName,AttrPrefix=attrPrefix, AttrSuffix=AttrSuffix)
						end()
					end()
				end()
			end()
		end()
	end()
	end()


	//Make sure all Attributes are correctly capitalized
	foreach(objects.keys,"KeyName")
		Set(Capitalized=regexReplace(keyName,"(\b\w|(?<=_)\w)","\u$1").text) //Capitalize word correctly
		eval("RenameAttr("&Capitalized&"="&keyName&")")
	end()

}


proc GetFourierDescriptors(
	objectlist objects inout "The object list containing cells of interest"
) object recognition, Fourier Descriptors
"Fourier Descriptors are a set of numbers that describes a shape using shape signatures and fourier transform"
"The following Shape Signature avaliable are:"
			"<li>  1: ComplexCoordinateFunction (CC)"
			"<li>  2: CentroidDistanceFunction (CD)"
			"<li>  3: AreaFunction (A)"
			"<li>  4: CumulativeAngularFunction (CA)"
			"<li>  5: CurvatureSignature (CS)"
			"<li>  6: PolarCoordinateFunction (PC)"
			"<li>  7: AngularRadiusFunction (AR)"
			"<li>  8: NormalizedComplexCoordinatesFunction (NCC)"
			"<li>  9: AffineInvariantMethod2009 (AIM)"
			"<li> 10: FarthestPointDistanceFunction (FPD)"
			"<li> 11: ArcHeightFunction (AH)"
			"<li> 12: SegmentedCentroidDistanceFunction (SCD)"

"Corresponding papers for a given shape signature are as follows:"
			"<li> Shape signature 1-5: D. Zhang, G. Lu, A Comparative Study of Fourier Descriptors for Shape Representation and Retrieval, in Proc. 5th Asian Conference on Computer Vision, 2002."
			"<li> Shape signature 6-7: I. Kunttu, L. Lepisto, Shape-based retrieval of industrial surface defects using angualr radius Fourier descriptor, Image Processing, IET, 2007 "
			"<li> Shape signature   8: E. Sokic, S. Konjicija, Novel Fourier Descriptor Based on Complex Coordinates Shape Signature, in 12th International Workshop on Content-Based Multimedia Indexing IEEE CBMI, 2014"
			"<li> Shape signature   9: P.L.E.Ekombo, N.Ennahnahi, M.Oumsis, M.Meknassi, Application of affine invariant Fourier descriptor to shape-based image retrieval, in IJCSNS International Journal of Computer Science and Network Security, 2009"
			"<li> Shape signature  10: A. El-ghazal, O. Basir, S. Belkasim, Farthest point distance: A new shape signature for Fourier descriptors, Signal Processing: Image Communication, 2009"
			"<li> Shape signature  11: G. Xu, Z. Mu, B. Nan, Shape Retrival using Improved Arc-Height Function, in Proceedings of the 2012 International Conference on Wavelet Analysis and Pattern Recognition, 2012"
			"<li> Shape signature  12: M.H. Sidram Nagappa U. Bhajantri, A Novel Shape Sinature of Geometric Mean of Segmented Centroid Distance Function to Track the Object through Fourier Descriptors, International Journal of Computer Applications, 2013"

"For Shape signature CumulativeAngularFunction, CurvatureSignature  and AngularRadiusFunction, the user has a choice of selecting the step size (an integer)"

"The step size (w) is used to calculate Delta(t) = atan((y(t)-y(t-w)) / (x(t)-x(t-w))), for t=0,1,...,N-1 where (x(t),y(t)) is the shape boundary coordinates, N is the number of boundary points and w is the input step size."
"Delta(t) is the angle between the x-axis and the line that contains the two points (x(t-w),y(t-w)) and (x(t),y(t))"
"Having a small step size value will give a more accurate description of the shape at the expense of computational speed"
"Bad input values of step size (w) are multiples of N (...,-2N,-N,0,N,2N,...)"
"This is because x(t-aN) = x(t) where a is an integer, which leads to a division of 0 in Delta(t)."

"For Shape signature SegmentedCentroidDistanceFunction, the user has a choice of selecting the number of segments (a positive integer)"

"The centroid distance is partitioned into segments indicated by the user where each segmented centroid distances are measured"
"The geometric mean of the segmented centroid distances is then calculated to give the desire shape signature"
"Refer to the corresponding paper for more information on the equations used"
"The authors mentioned that partitioned into two segments gave the best results. Hence, we set default value as two"
"Bad input values are clearly non-positive integers"
{
	//Give input parameters for FourierDescriptorsSelection_inner()
	FourierDescriptorsSelection_input()
	FourierDescriptorsSelection_inner()
}


proc FourierDescriptorsSelection_input(
	int NumberOfFourierDescriptors out "Number of Fourier_Descriptors to output.",
	int StepSize out "The size of the step",
	int NumberSegments out "The number of segments when partitioning the centroid.",
	string ShapeSignatureChoice out "Name of the shape signature chosen by the user"

)[hidden] object recognition, Fourier Descriptors "A set of numbers that describes a shape using shape signatures and fourier transform",
{
	input(ShapeSignatureChoice,"ComplexCoordinateFunction", "Shape Signature:Cell Features", "s", "Name of the shape signature chosen by the user. Allowed values: \"ComplexCoordinateFunction\", \"CentroidDistanceFunction\", \"AreaFunction\", ,\"CumulativeAngularFunction\", \"CurvatureSignature\",\"PolarCoordinateFunction\", \"AngularRadiusFunction\", \"NormalizedComplexCoordinatesFunction\", \"AffineInvariantMethod2009\", \"FarthestPointDistanceFunction\", \"ArcHeightFunction\", \"SegmentedCentroidDistanceFunction\",\"Testing\"")
	input(NumberOfFourierDescriptors, 4, "Number of Fourier Descriptors:Cell Features", "i", "Indicate the number of 'FourierDescriptors'. Use '0' to use the methods default. Allowed range: 0..1024, step 1.")
	input(StepSize, 1, "Step Size:Cell Features", "i", "Applicable to Shape Signature \"CumulativeAngularFunction\",\"CurvatureSignature\" and \"AngularRadiusFunction\" for calculating of Delta(t) = atan((y(t)-y(t-w)) / (x(t)-x(t-w))), for t=0,1,...,N-1 where (x(t),y(t)) is the shape boundary coordinates, N is the number of boundary points and w is the input step size. Allowed range: 1..10, step 1.")
	input(NumberSegments, 2, "Number of Segments:Cell Features", "i", "Applicable to Shape Signature \"SegmentedCentroidDistanceFunction\" to give the number of segments when partitioning the centroid. Allowed range: 1..4, step 1.")
}


proc FourierDescriptorsSelection_inner(
	objectlist objects inout "The object list containing cells of interest",
	string ShapeSignatureChoice="ComplexCoordinateFunction" in "Name of the shape signature chosen by the user",
	int NumberOfFourierDescriptors=4 in "Indicate the number of Fourier_Descriptors to output.",
	int StepSize=1 in "Applicable to Shape Signature 4,5 and 7 for calculating of Delta(t) = atan((y(t)-y(t-w)) / (x(t)-x(t-w))), for t=0,1,...,N-1 where (x(t),y(t)) is the shape boundary coordinates, N is the number of boundary points and w is the input step size.",
	int FactorInput=16 in "Applicable to Shape Signature 11 as we require the arc length between pi1 and pi, pi2 and pi to be N/f where N is the number of boundary points and f is the input factor. Refer to paper \"Shape Retriveval Using Improved Arc-Height Function\" for more information.",
	int NumberSegments=2 in "Applicable to Shape Signature 12 to give the number of segments when partitioning the centroid."

)[hidden] object recognition, Fourier Descriptors "A set of numbers that describes a shape using shape signatures and fourier transform"
{

	//Define a list of Shape Signature avaliable to user
	set(ShapeSignatureList = 	vec("ComplexCoordinateFunction","CentroidDistanceFunction","AreaFunction","CumulativeAngularFunction","CurvatureSignature","PolarCoordinateFunction","AngularRadiusFunction","NormalizedComplexCoordinatesFunction","AffineInvariantMethod2009","FarthestPointDistanceFunction","ArcHeightFunction","SegmentedCentroidDistanceFunction"))


	//If user wants to test, all Shape Signatures are choosen
	if(ShapeSignatureChoice=="Testing")
		set(ShapeSignatureChoice=ShapeSignatureList)
	else()
		set(ShapeSignatureChoice=vec(ShapeSignatureChoice))
	end()

	foreach(0..ShapeSignatureChoice.length-1,"ShapeSignature")
		if(FindElem(ShapeSignatureChoice[ShapeSignature],ShapeSignatureList).pos < 0)
			Warning("The shape signature \""&ShapeSignatureChoice[ShapeSignature]&"\" selected for the Fourier Descriptor is invalid. Please check that you have keyed in name correctly")
			continue()
		end()
		//Apply the Fourier_Descriptors module in libNITD_FourierDescriptors.so.2.7
		Fourier_Descriptors(objects.border,ShapeSignatureChoice[ShapeSignature],NumberOfFourierDescriptors,StepSize,NumberSegments)

		//Copy output into objects
		foreach(fsd.keys, "descriptor")
			set(objects[descriptor]=fsd[descriptor])
		end()
	end()

}