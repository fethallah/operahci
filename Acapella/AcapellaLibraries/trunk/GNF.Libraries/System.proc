//#############################################################################################
//# Acapella Script and procedures Collection: A collection of Acapella based scripts
//# and libraries.
//#
//# Please acknowledge the author(s) for making use of these scripts and library.
//# Authors:
//#   * Ghislain M.C. Bonamy
//#   * Genomics Institute of the Novartis Research Foundation (GNF), San Diego, CA 92122
//#   * www.gnf.org
//#
//# You can obtain the latest version of this software at: http://code.google.com/p/operahci/
//#
//# This program is free software; you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation; either version 2 of the License, or
//# (at your option) any later version.
//#
//# This program is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with this program; if not, write to the Free Software
//# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//# or go to: http://www.apache.org/licenses/
//#############################################################################################

//*********************************************************************************************
//*
//* This library defines a set of miscellaneous tools to interact with system.
//*
//*********************************************************************************************



proc getConfiguration(
String path in "Path of the configuration file. The path can be absolute (ie. start with '/' or '\\') or relative starts with '.' or nothing.",
Container config out "Object containing the configuration"
)System "Returns the configuration embedded into the selected file located at the root of this procedure"
{
if(at( "/",path)!=1 && at( "\\",path)!=1)
	sprintf(configFile,"%s%s",pathSplit(__file__).dirname,path)
end()

readIni(configFile|config=ini)

set(platform = __platform__ )
if(defined("config." & platform))
	set(config=mergeContainer(config, config[platform]).container)
end()

if(path=="GNF.ini" && !defined("config.paths.tmp"))
	//Extract actual temp diretory from system. In future need to test if tmp path in
	//system file exists or replace with system one...
	if(!defined("config.paths"))
		set(config.paths=cnt())
	end()
	set(config.paths.tmp = regexreplace(getLocalTempDir().dirname,"[\\/]$","").text)
end()
}

proc getLocalTempDir(
	string dirname out "Path to the temporary folder on the system"
) System "Returns the path to the temporary directory on the system"
{
	MakeTempFileName()
	DeleteFile(filename)
	pathSplit(filename)
	sprintf(dirname,"%s/%s",dirname,"acapella")
	set(dirname=convertPath2Platform(dirname).path)
}

proc convertPath2Platform(
string path inout "Path that needs to be converted to match the current system",
string platform = __platform__ in "System to use, either 'unix' or 'windows'"
)System "Converts path provided as strings into a valid representation on the target system. This is useful for running external commands."
{

//TODO: Handle user paths (~/, ~USER/, %USERPROFILE%...)
if(platform=="unix")
	if(regex(path,"^\\w:").matches.length>0)
		error(sprintf(e,"The Path you are trying to use: '%s' cannot be converted to unix format. Use UNC style paths").e)
	end()
	set(path=regexreplace(path,"\\\\+","/").text)
	set(path=regexreplace(path,"/+","/").text) //In linux \ (and // are meaningless)
	return()
elif(platform=="windows")
	set(path=regexreplace(path,"/+","\\\\").text)
	set(path=regexreplace(path,"\\\\+","\\\\").text)
	set(path=regexreplace(path,"^\\\\(?=[^\\\\])","\\\\\\\\").text) //Make sure that UNC starts with '\\' and not '\'
	return()
else()
	error(sprintf(e,"The platform provided: '%s' is not valid. Must be one of 'unix' or 'windows'", platform).e)
end()
}

proc readIni(
string path in "path of the INI file that you want to use.",
container ini out "Container representing the INI file that you read."
)
System "Reads an INI file into an object so that each Groups (eg. [MyGroup1\MyGroup2\MyGroup3]) represents one branch into the ini container returned. The values are placed into the structure created. If you provide a ';'delimited sets of value for one key eg. 'MyValues=3;2;3;6;4' a vector o values will be entered in the selected group. Notion of Super groups is also introduce to further group set of objects. Super groups are provided by a line containing a line with the following template: '{A_Super_Group_Label}'."
{
rename(path=path)
if(!fileInfo(path).fileinfo.is_readable)
	Error(sprintf(e,"The configuration file: '%s' is missing", path).e)
end()
ReadFile(path)
SplitString(content,"\n",Trim=true|Content=Split)
set(ini=cnt(),lineIndex=0, currentGroup="ini", superGroup="")
Foreach(Content,"line")
	Set(lineIndex=lineIndex+1)

	//Handle comments and empty lines
	Regex(line, "^;")
	if(matches.length>0 || line=="")
		continue()
	end()

	//Handle Super Groups
	Regex(line, "^\\s*\\{(.*?)\\}\\s*$")
	if(matches.length>0)
		set(currentKey=matches[0])

		if(Regex(currentKey, "^\\s*\\w+\\s*$").matches.length==0)
			Error(sprintf("text","Invalid Ini file: ''%s'. The super group: '%s' at line %s, contains an invalid characters.",path, line, lineIndex).text)
		end()
		set(superGroup="ini"&"."&currentKey)
		set(_[superGroup]=cnt())
		continue()
	end()

	//Handle Groups
	Regex(line, "^\\s*\\[(.*?)\\]\\s*$")
	if(matches.length>0)
		set(currentKey=matches[0])
		RegexReplace(currentKey,"/$",""|currentKey=text)
		RegexReplace(currentKey,"\\\\","/"|currentKey=text)

		if(Regex(currentKey, "^[\\w/]+$").matches.length==0)
			Error(sprintf("text","Invalid Ini file: ''%s'. The group: '%s' at line %s, contains an invalid characters.",path, line, lineIndex).text)
		end()
		SplitString(currentKey,"/"|keys=Split)
		Set(currentGroup=iif(superGroup=="", "ini", superGroup))
		Foreach(keys,"key")
			set(currentGroup=currentGroup&"."&key)
			if(!defined(""&currentGroup))
				set(_[currentGroup]=cnt())
			end()
		End()
		continue()
	end()

	//Handle Values
	Regex(line, "^(.+?)=(.+)$")
	if(matches.length>0)
		set(key=matches[0],value=matches[1])
		if(Regex(key, "^\\w+$").matches.length==0)
			Error(sprintf("text","Invalid Ini file: ''%s'. The key: '%s' at line %s, contains an invalid characters.",path, key, lineIndex).text)
		end()

		RegexReplace(value,"(?:\s+)|(?:\s+$)",""|value=text) //remove trailing spaces
		if(value.length==0) continue() end()

		if(at("\"",value,1)==1 && at("\"",value,-1)==value.length)
			SplitString(value,"\";\""|values=split) //Handle escaping
			if(values.length>1)
				RegexReplace(values,"(?:^\")|(?:\"$)",""|values=text)
				set(_[currentGroup][key]=values)
				continue()
			end()
			RegexReplace(value,"(?:^\")|(?:\"$)",""|value=text)
			set(_[currentGroup][key]=value)
		else()
			SplitString(value,";"|values=split)
			if(values.length>1)
				set(_[currentGroup][key]=values) 
				continue()
			end()
			set(_[currentGroup][key]=value)
		end()
	end()
	//Warning(sprintf("text","Invalid Ini file: '%s'. Unexpected error at line %s.",path, line, lineIndex).text)
end()
}

proc resolveRMCAImageLocation(
	string path in "Current location of images returned by Single well",
	string path out "Location of the image"
) [hidden]  "This procedure helps resolves images served by the RMCA platform"
{
	set(config=getConfiguration("GNF.ini").config)
	set(locations=vec(config.paths.storageRoot))
	append(locations, SplitString(config.paths.archiveRoot,":").split)

	if(at("rmca:",path)>0)
		Set(filename = RegexReplace(path,"rmca:","").text)
		foreach(locations, "location")
			sprintf(filename,"%s/%s",location,filename)
			set(filename=convertPath2Platform(filename).path)
			if(fileinfo(filename).fileinfo.exists)
				break()
			end()
		end()
		rename(path=filename)
	end()
}

proc getWriteLocation(
	string path in "Current location of the image",
	string path out "The location where data should be written"
) FileSystem "Get the location where the data should be written, based on current image location. Data will be writen normally inside the storage location defined in the ini file, or when in interactive mode inside a temp location defined in the ini file."
{
	set(config=getConfiguration("GNF.ini").config)
	set(locations=vec(config.paths.storageRoot))
	append(locations, SplitString(config.paths.archiveRoot,":").split)

	set(path=convertPath2Platform(path).path)
	set(storageRoot=convertPath2Platform(config.paths.storageRoot).path)

	EnvInfo()
	set(isInteractive=env_interactive && env_supports_graphview && env_supports_htmlview && env_supports_imageview && env_supports_tableview)
	foreach(locations, "location")
		set(location=convertPath2Platform(location).path)
		if(at(location,path)>0)
			set(path=substr(path,length(location)+1,-1))
			if(isInteractive)
				sprintf(path, "%s/%s", config.paths.tmp, path)
			else()
				sprintf(path, "%s/%s", storageRoot, path)
			end()
			break()
		end()
	end()
	set(path=convertPath2Platform(path).path)
}


//fix bug in mkdir that prevent UNC path to be properly created
proc mkdir2(
	String dirname in "The name of the directory to be created. Can be absolute, or relative to the current directory.",
	string mode="777" in "Directory attributes, for Linux only. This mode is combined with the user's umask, which normally prohibits write access to group/others. Default: 777 (i.e. access is effectively controlled by the umask value only).",

	boolean errorThrowing=false in "If this is true an error will be thrown, otherwise a simple warning will be given."
) Filesystem "Creates a new directory. Also creates un-existing parent directories recursively."
{

	set(dirname=convertPath2Platform(dirname).path)
	set(dirname=regexreplace(dirname,"/$|\\\\$","").text)
	if(FileInfo(dirname).fileinfo.exists)
		return()
	end()

	if(__platform__=="windows")
		sprintf("cmd","mkdir \"%s\"",dirname)
		Run(cmd, stderr="<errorMsg")
	else()
		sprintf("cmd","mkdir -p '%s' -m '%s'",mode, dirname)
		Run(cmd, stderr="<errorMsg")
	end()
		if(errorlevel!=0)
		sprintf("errorMsg","mkdir command: %s; ErrorMessage: %s", cmd, errorMsg)
		if(errorThrowing)
			error(errorMsg)
		else()
			warning(errorMsg)
		end()
	end()
}