#ifndef x_IMACRO_MEMBLOCK_H_INCLUDED
#define x_IMACRO_MEMBLOCK_H_INCLUDED

#include <set>
#include <map>
#include <cmath>  // for std::abs()
#include <limits> // <Limits> issues spurious warnings at warning level 4.

// Use NIMacro namespace for MemBlock project
// Redefine NMemBlock - this is automatically generated by DI_Export.bat
#ifndef NMemBlock
#define NMemBlock NIMacro
#endif

#include "safevalue.h"
#include "pmemblock.h"
#include "triple.h"
#include "error.h"
#include "refcounted.h"

namespace NIMacro {


// forward declarations
class MemBlock;
class MemBlockFactory;
class Formatter;
class ConvertOptions;
class op_options;
class MemBlockImpl;
class TraverseVisitor;
class AcaVisitor;
struct TraverseNode;

using Nbaseutil::ThrowIndeed;
using Nbaseutil::ThrowNever;
using Nbaseutil::DoNothing;
void MemTrackCapture(const MemBlock* m);

/** 
* @brief A virtual base class for scanning hierarchical data structures containing MemBlock and/or DataItem objects.
* Derive a concrete class from this class to scan several containers.
* See MemBlock::Accept(), MemBlock::IterateChildren(), MemBlock::Entertain(), DataBlock::ScanItems().
* See also NIMacro::ItemVisitor.
*/
class MemBlockVisitor: public Nbaseutil::mb_malloced {
public:
	// Change 19.12.2008: enlarge the return values for supporting DeepCopier better.
	enum order_t {
		stop_scan=0,
		continue_scan=1,
		skip_child_enter=2,
	};
	/**
	* For scanned MemBlock objects in the data structure this function will be called by the scanning functions.
	* Override this function to perform needed actions.
	* @return Return continue_scan to continue scanning; return stop_scan to abort scanning; return skip_child_enter to continue scanning, but instruct the caller to not call Entertain() on the currently visited object.
	* @param name - if container supports some kind of names for its items, the name of the item (full path) is passed, otherwise an empty string.
	* @param item - reference to the passed item smartpointer inside the container's data structures. The smartpointer may be reseated inside the function.
	*/
	// Enh 08.08.2005: pass poItem by reference to provide more functionality.
	virtual order_t Visit(const Nbaseutil::safestring& name, PMemBlock& item) = 0;

	/**
	* If the data structure contains DataItem's, then this Visit() method is called
	* instead. The MemBlockVisitor base class method calls Visit() with MemBlock parameter
	* if the DataItem contains a MemBlock, otherwise does nothing. 
	* Override if you want to perform actions for non-MemBlock DataItem objects as well.
	* @return Return true to continue scanning; return false to abort scanning.
	* @param name - if container supports some kind of names for its items, the name of the item (full path) is passed, otherwise an empty string.
	* @param item - reference to the DataItem inside the container's data structures. The DataItem may be assigned a new value inside the function.
	*/
	DI_MemBlock virtual order_t Visit(const Nbaseutil::safestring& name, DataItem& item);

	/**
	* A function for supporting visiting of memblocks part of whose data may be partially invalid/out of date (in particular, see class Attribute in ../cells/cells.h)
	* If the exact data content of MemBlock is not important for functioning, override this method to return false.
	*/
	virtual bool NeedsValidData() {return true;}
	
	virtual ~MemBlockVisitor() {}
};

/**
* A callback class for forwarding the callback back to a class method.
* class T must contain methods:
*	- bool VisitMemBlock(const Nbaseutil::safestring& name, PMemBlock& item);
*	- bool VisitMemBlock(const Nbaseutil::safestring& name, DataItem& item);
* See the MemBlockVisitor class description for meaning of the 
*/
template<class T> // class T must contain method bool VisitMemBlock(const Nbaseutil::safestring& name, PMemBlock& item);
class CallBackMemBlockVisitor: public MemBlockVisitor {
	T& t_;
public:
	CallBackMemBlockVisitor(T& t): t_(t) {}
	virtual order_t Visit(const Nbaseutil::safestring& name, PMemBlock& item) {
		return t_.VisitMemBlock(name, item);
	}
	virtual order_t Visit(const Nbaseutil::safestring& name, DataItem& item) {
		return t_.VisitMemBlock(name, item);
	}
};

// Forward declarations
class DI_MemBlock Image;
typedef DerivedPointer<Image> PImage;
// template struct DI_MemBlock DerivedPointer<Image>;		// This trick is needed for avoiding MSVC++ warning C4251.
class DI_MemBlock op_options;	
class DI_MemBlock Vector;
typedef DerivedPointer<Vector> PVector;
class DI_MemBlock Container;
typedef DerivedPointer<Container> PContainer;

/// Returns a reference to a global throwhandler object which passes errors to Warning() calls.
DI_MemBlock Nbaseutil::ThrowHandlerBase& LogWarnings();

/// A helper base class for use by MemBlock::Serialize(). See also TraverseSerializeVisitor class.
class DI_MemBlock SerializeVisitor: public Nbaseutil::mb_malloced {
public:
	SerializeVisitor(const Nbaseutil::safestring& tmpname_prefix="__ser__"): tmpname_prefix_(tmpname_prefix), tmpname_k_(0) {}

	/// By default, Descend() is not called for scalar subobjects, like numeric vector elements. Override this function to call Descend() also for such subobjects.
	virtual bool DescendIntoScalars() const {return false;}

	/**
	* Serialization descends into an subobject of the parent object. 
	* If DescendIntoScalars() returns false (the default), then the type of subobject is either Memory or Sharable.
	* The base class implementation calls Serialize() on the subobject with same parameters, if the subobject is a MemBlock or Sharable, and does nothing
	* otherwise.
	* @param subobject The subobject to descend to. 
	* @param ser_format The serialization format. This should be a ser_* constant defined in a MemBlock hierarchy or the Formatter class. An ERR_NOTIMPLEMENTED Exception is thrown if the object does not support the format.
	* @param itemname The full pathname of the subobject.
	* @param formatter Holds detailed options for serialization.
	* @param buffer The serialization output buffer. Serialized content has to be appended to the end of buffer.
	*/
	virtual void Descend(DataItem subobject, int ser_format, const Nbaseutil::safestring& itemname, const Formatter& formatter, Nbaseutil::safestring& buffer);

	/// Return a new simple acapella item name, not colliding with any other name issued by this object.
	Nbaseutil::safestring GetNewTmpName() {return tmpname_prefix_ + Nbaseutil::str(++tmpname_k_);}

	virtual ~SerializeVisitor(){}

private: // implementation
//	void CleanupRegisteredObjects();	

private:
//	typedef std::map<const void*, void*, std::less<const void*>, Nbaseutil::mb_allocator_typedef< std::map<const void*, void*>::value_type >::allocator > map_t;
//	map_t map_;
	Nbaseutil::safestring tmpname_prefix_;
	int tmpname_k_;
//	bool in_cleanup_;
};

/** 
	@brief The abstract base class for MemBlock class hierarchy.

	This class attempts to provide two different interfaces for derived classes: memory management and Acapella dataitem functionality. 
	It would be more clear to break these interfaces into two different classes, but this has not yet been done.

	The dataitem interface provides methods for getting and setting subitems, support for conversions and serialization. Also recursive 
	scanning of contained subitems belongs to this interface.

	The memory management part involves encapsulating a (generally of large size) memory area 
	and deals with memory allocation and deallocation for it. The primary users of this functionality are the 
	Vector, Image and DataCube classes.

	MemBlocks are created on heap only, and passed around via the PMemBlock hierarchy reference-counted smartpointers. Each derived class has one or more 
	static Create() functions, which create an instance of the class and return the smartpointer.

	By using the Clone() method the new MemBlock object may share the malloced memory area with the original MemBlock. The memory management 
	is done by a second-level reference count (so-called clone count). The MemBlock-s are detached (copy of the memory area made) when one of them
	calls the non-const Pointer() method for accessing the memory area.

	MemBlock hierarchy objects may be accessed in one thread at a time only. For passing a MemBlock to another thread it has to be encapsulated 
	in a DataItem object and DataItem::MakeCopy member has to be called. This ensures in deep recursion that the memory which the object uses 
	is not shared by any other object.
*/
class DI_MemBlock MemBlock: public Nbaseutil::mb_malloced {
public: // enums and constants 
	/// Constants for object logic type.
	enum lg_type_enum {
		/// Dummy type.
		lg_default=0,
	};

public: // static interface

	/// Returns the reference to the MemBlockFactory singleton instance.
	static MemBlockFactory& Factory();

public: // interface

	/** 
	* Make a copy of the object for subsequent modification. See also CloneExact(), CloneForThreadPass(), MakeDeepCopy().
	*
	* The copy will have the same dynamic type and properties than the original, except for transient attributes like min/max/@md5,
	* which are flushed as the object is meant to be modified by the caller immediately.
	*
	* Any contained objects and memory blocks can remain in shared use.
	* This function calls the virtual DoClone() member function for doing most of the work.
	*
	* @param copy_content If the memblock manages a raw C data array (Vector and its derivative classes), then 
	*		the clone will logically have the same managed memory content as the original object. 
	*		The actual memory duplication may be delayed until calling non-const Pointer() method either on the original object or clone.
	*		Thus is is encouraged to use "const PMemBlock" hierarchy pointers wherever possible, in order to reduce memory footprint.
	*/
	PMemBlock Clone(bool copy_content=true) const;

	/**
	* Make a copy of the object, which is not intended for immediate modification.
	* This is the same as Clone(true), except that it also copies transient attributes.
	*/
	PMemBlock CloneExact() const;

	/**
	* Makes a copy of the object, which is intended to sent over to another thread without any modification.
	* This is equivalent of the combination of CloneExact() and MakeDeepCopy().
	*/
	PMemBlock CloneForThreadPass() const;

	/**
	* Makes a deep physical copy of the object, including copy of all numeric arrays.
	* This is equivalent of the combination of CloneExact() and MakeDeepPhysicalCopy().
	*/
	PMemBlock CloneDeepPhysical() const;

	/**
	* Returns a partially cloned copy of the object. Subobjects in the copy are cloned partially up to the specified branch. 
	* @param branch Names a subitem in the object. The subitem is ensured to be referred only from inside the returned main object.
	*/
	PMemBlock CloneToBranch(const Nbaseutil::safestring& branch) const;


	/**
	* Copy over sticky attributes from src to this object. This is done by Clone() automatically, 
	* this function is needed only when Clone() is not used by any reason, but one wants
	* to pass "identity" of the src object to this object.
	*/
	void CopyStickyAttributesFrom(const MemBlock& src);


	/// Ensure that the object and any logically contained objects are visible only through this pointer. Such an object can be passed safely to another thread.
	void MakeDeepCopy();

	/// Same as other MakeDeepCopy() overload, but outputs a comma-separated list of subitems which had to be copied in order to make the object safe for passing thread boundaries.
	void MakeDeepCopy(Nbaseutil::safestring& copied_nodes);


	/**
	* @brief Value comparison. 
	*
	* This compares the data content, for comparing the object addresses use the PMemBlock::Pointer() method. 
	* 
	* Most derived classes should override this comparison operator. 
	* These should call the base class version first and continue only in case of equality.
	*/
	bool operator==(const MemBlock& b) const;

	/**
	* @brief Return a short description of the object. 
	* 
	* This calls the virtual DoGetDescription() method.
	*/
	Nbaseutil::safestring GetDescription() const;

	/// Deprecated, use GetDescription() instead.
	Nbaseutil::safestring ToString() const {return GetDescription();}

	/**
	* Serialize the MemBlock object into the string buffer.
	* This calls the virtual DoSerialize() method.
	* @param ser_format The serialization format. This should be a ser_* constant defined in a MemBlock hierarchy or the Formatter class. An ERR_NOTIMPLEMENTED Exception is thrown if the object does not support the format.
	* @param visitor A callback visitor object for advanced overriding of the behaviour. The visitor is called for descending into subobjects. For simple serialization create and pass an object of SerializeVisitor class.
	* @param itemname The name of the object.
	* @param formatter Holds detailed options for serialization.
	* @param buffer The serialization output buffer. Serialized content is appended to the end of buffer.
	*/
	void Serialize(int ser_format, SerializeVisitor& visitor, const Nbaseutil::safestring& itemname, const Formatter& formatter, Nbaseutil::safestring& buffer) const;

	/**
	* UnSerialize the MemBlock object present in the string buffer. This object remains unchanged, i.e. this is kind of "static virtual" function.
	* This calls the virtual DoUnSerialize() method.
	* @param ser_format The serialization format. This should be a ser_* constant defined in a MemBlock hierarchy or the Formatter class. If unknown, pass Formatter::ser_unknown here.
	* @param formatter Holds detailed options for serialization.
	* @param buffer The serialization input buffer. 
	* @param p_buff_end An output parameter. If not NULL, a pointer to the next byte after the unserialized object is stored in *p_buff_end.
	*/
	PMemBlock UnSerialize(int ser_format, const Formatter& formatter, const char* buffer, const char** p_buff_end=NULL) const;

	/**
	* Return an attribute value or a subitem contained in this object. See also: NIMacro::InitByExpression() function.
	* @param subitemname The name of a key or a subobject. Can contain nested subitem and key names, separated by dots.
	*		The square brackets are not supported here as here is no datablock to evaluate the expressions in the brackets.
	*		If the subitem name contains characters invalid in Acapella names, then the name must be name-quoted (see Nbaseutil::QuoteName()).
	*
	*       The difference between keys and subobjects is that keys are calculated by-demand when queried, whereas subobjects are genuine
	*		objects making up the data structure, like table columns. 
	*
	*		If subitemname is "*", then a comma-separated list of all genuine subobjects is returned. 
	*       If subitemname is "!", then a comma-separated list of all supported keys is returned.
	*       If subitemname is empty, then a joint list of all subobjects and keys is returned.
	*		In the last two cases "technical" keys are prepended by a percent sign (%). These should not be immediately visible to the user.
	*
	*		For the classes which can contain subobjects, the key names begin with the @-sign, in order to differentiate from subobjects. 
	*		Historically there was no such convention, thus key names without @-signs are also recognized for back-compatibility. 
	*		However, if @-sign is present, then preference 
	*		is given to the keys; if it is not, then preference is given to subobjects. 
	* @param throwhandler The handler for processing any errors during the subitem resolving. The default handler just throws the exception, 
	*		passing the DoNothing or ThrowNever handler will yield an Undefined return value.
	* @return The attribute value or subitem, or Undefined if the item was not found and non-throwing throwhandler was used.
	*/
	SafeValue GetSubItem(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed) const;

	/// Return a subitem type, or Undefined if subitem is not found and non-throwing throwhandler was passed. See GetSubItem() for more details.
	ItemType GetSubItemType(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed) const; 

	/// Return a subitem converted to int, or 0 if subitem not found/not convertible and non-throwing throwhandler was passed. See GetSubItem() for more details.
	int	GetSubItemInt(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed) const; 

	/// Return a subitem converted to int, or 0.0 if subitem not found/not convertible and non-throwing throwhandler was passed. See GetSubItem() for more details.
	double GetSubItemDouble(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed) const; 

	/// Return a subitem converted to string, or an empty string if subitem not found/not convertible and non-throwing throwhandler was passed. See GetSubItem() for more details.
	Nbaseutil::safestring GetSubItemString(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed) const; 

	/// Return a subitem converted to a pointer, or NULL if subitem not found/not convertible and non-throwing throwhandler was passed. See GetSubItem() for more details.
	void* GetSubItemPointer(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed) const;

	/// Return a subitem converted to memblock, or NULL if subitem not found/not convertible and non-throwing throwhandler was passed. See GetSubItem() for more details.
	PMemBlock GetSubItemMemBlock(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed, const char* pszClassname=NULL) const;

	/// Return a subitem converted to a vector of specified type, or NULL if subitem not found/not convertible and non-throwing throwhandler was passed. See GetSubItem() for more details.
	PVector GetSubItemVector(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed, const char* pszClassname=NULL, const Nbaseutil::safestring& elemtype="") const;
		

	/**
	* Sets a subitem value inside the MemBlock object hierarchy. This is a quite high-level operation.
	* It finally calls DoSetSubItem() virtual function on the final MemBlock object, see supported subitemname values
	* in the descriptions of relevant DoSetSubItem() overrides.
	* @param subitemname Subitem path name, in dot syntax.
	* @param item Subitem value. The needed type of the item depends on the subitem names.
	* @param throwhandler The handler for processing any errors during the subitem setting. 
	*		The default handler throws an exception in case of problems. 
	*		Passing DoNothing or ThrowNever will silently ignore errors.
	* @return Returns true, if the subitem has been successfully set.
	*/
	bool SetSubItem(const Nbaseutil::safestring& subitemname, const SafeValue& item, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed);

	/**
	* This function has to be called immediately after changing data content of the object.
	* It will flush cached secondary data item values (except sticky attributes).
	* In Debug build it also flushes data checksums used for monitoring invalid data access.
	* A failure to forget to call this function may result in out-of-date values returned from SecondaryItem() calls.
	* In Debug builds the checksum errors may also be reported.
	*/
	void ContentHasBeenChanged();


	/// Flags for using with ContentHasBeenChanged().
	enum contentchangeflags_t {
		/// Only data in numeric Vector arrays has been changed.
		content_change_pixeldata = (1<<0),
		/// Only attributes or subobjects changed, no change in numeric Vector arrays.
		content_change_attributes = (1<<1),
	};

	/**
	* A finer control version of another overload of ContentHasBeenChanged().
	* @param flags Allows for specifying in more detail, what exactly has been changed, for enhancing performance.
	*/
	void ContentHasBeenChanged(contentchangeflags_t flags);

	/**
	* Return a secondary item (calculated property) for this MemBlock. The secondary items are generally cached 
	* and thus only the first call may perform lengthy calculations. The cache can be cleared
	* by calling the ContentHasBeenChanged() function.
	* @param key Identifies possible property. 
	*		The valid keys depend on the dynamic type of the object.
	*		The valid key values are listed as key_* enum values in the class definition of the
	*		object. Also the keys for all parent classes can be used.
	*		Also, any keys set by SetSecondaryItem() are returned.
	* @param throwhandler A ThrowHandler object for defining the behaviour in case of problems.
	*		The default handler throws an exception in case of any problems.
	* @return The secondary key value. If the key value was not present 
	*		and could not be calculated and the throwhandler decided not to throw, then Undefined is returned.
	*/
	DataItem SecondaryItem(int key, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed) const;

	/// Return a secondary item converted to int. Refer to the SecondaryItem() documentation.
	int SecondaryInt(int Key, Nbaseutil::ThrowHandlerFunc th=ThrowIndeed) const;

	/// Return a secondary item converted to double. Refer to SecondaryItem() documentation.
	double SecondaryDouble(int Key, Nbaseutil::ThrowHandlerFunc th=ThrowIndeed) const;

	/// Return a secondary item converted to MemBlock. Refer to SecondaryItem() documentation.
	PMemBlock SecondaryMemBlock(int Key, Nbaseutil::ThrowHandlerFunc th=ThrowIndeed) const;

	/**
	* Set a secondary item (calculated property) value in the secondary items' cache. 
	* The cache will be cleared when ContentHasBeenChanged() is called (except keys above 10000).
	* @param key Identifies possible property. 
	*		The valid values depend on the dynamic type of the object.
	*		The valid values are listed as key_* enum values in the class definition of the
	*		object. Also the keys for all parent classes can be used.
	*		One can use also other key values, provided that these do not clash with existing keys.
	*		The following ranges are defined:
	* - 1..2000 Used by Acapella system itself.
	* - 2001..8000 Reserved for use by redistributable Acapella-related libraries from third-parties after registration a subrange by Acapella development team.
	* - 8001..10000 Custom range, can be used by in-house Acapella-related libraries.
	* - 10001..12000 Sticky key range used by Acapella itself.
	* - 12001..18000 Sticky key range reserved for use by redistributable Acapella-related libraries from third-parties after registration a subrange by Acapella development team.
	* - 18001..20000 Sticky key custom range, can be used by in-house Acapella-related libraries.
	* @param value The key value. Pass Undefined to clear the existing key value, if any.
	*/
	void SetSecondaryItem(int key, const DataItem& value) const;	// Force setting of secondary attribute.

	/**
	* Check if a secondary item value is present in the cache, and return it in this case.
	* No attempt is made to calculate the secondary item, if it is not found in the cache.
	* @param key Property key. See SetSecondaryItem() for details.
	* @param value Output parameter. If found, the property value is returned here.
	* @return True, if the key was found in the cache.
	*/
	bool ExistsSecondaryItem(int key, DataItem& value) const;

	/**
	* Check if a secondary item value is present in the cache, and return it converted to int in this case.
	* If not convertible to int, value 0 is returned.
	* See ExistsSecondaryItem() for details.
	*/
	bool ExistsSecondaryInt(int key, int& value) const;	// return the presence and value of secondary integer. No calculation performed. If not found, the Value is unchanged.

	/**
	* Check if a secondary item value is present in the cache, and return it converted to double in this case.
	* If not convertible to double, value 0.0 is returned.
	* See ExistsSecondaryItem() for details.
	*/
	bool ExistsSecondaryDouble(int key, double& value) const;	// return the presence and value of secondary double. No calculation performed. If not found, the Value is unchanged.

	/// Key values for using with the secondary item facility.
	enum secondary_item_keys {
		/// MD5 hash string of the item (all contained items taken into account). Value type: string.
		key_md5 = 1,
		/// Value of the MemBlock object if represented as an integer. This is generally impossible and unimplemented. Value type: int.
		key_to_int = 2,
		/// Value of the MemBlock object if represented as a double. This is generally impossible and unimplemented. Value type: double.
		key_to_double = 3, 
		/// MD5 hash string, does not require valid data content. Used internally in Debug builds. Value type: string.
		key_md5_shallow = 4,
		/// Used internally in Debug builds. Value type: int (0 or 1).
		key_consistency_checked = 5,
		/// Remembered MD5 hash of the object. Used internally in Debug builds for detecting illegal modification.
		key_checksum_string = 6,
		/// Script-level non-sticky attributes.
		key_transient_attr = 7,
		// keys above 10000 designate sticky attributes (not deleted by ContentHasBeenChanged())
		/// Sticky attribute - owner thread ID, used internally in Debug builds. Value type: int.
		key_thread_id = 10002,
		/// Script-level sticky attributes
		key_sticky_attr = 10003,
	};

	/**
	* Generic MemBlock object conversion. 
	* Converts this object into another, possible of another class.
	* This calls virtual AddConvertArg(), ConvertTo() and ConvertFrom() functions.
	* @param optionlist List of additional conversion options. These must be understandable to the destination class.
	* @param classname The name of the class to convert to. The default (empty string) means that dynamic type should remain unchanged.
	* @param throwhandler_for_option_processing Throwhandler to use while processing the options list. The default logs warnings via Warning(). Other errors are reported by real exceptions.
	* @return Converted object. NULL is never returned. If conversion was not possible, an exception is thrown.
	*/
	PMemBlock Convert(const Nbaseutil::safestringlist& optionlist, const Nbaseutil::safestring& classname="", Nbaseutil::ThrowHandlerFunc throwhandler_for_option_processing=LogWarnings()) const;

	/// Same as the other Convert() overload except that options are specified in a string argument, separated by spaces, tabs, commas or semicolons.
	PMemBlock Convert(const Nbaseutil::safestring& options, const Nbaseutil::safestring& classname="", Nbaseutil::ThrowHandlerFunc throwhandler_for_option_processing=LogWarnings()) const {
		return Convert(Nbaseutil::SplitString(options, " \t,;"), classname, throwhandler_for_option_processing);
	}


	/**
	* Process conversion options list in string format and add options to the opt object. 
	* This method is called on the destination class type object (most probably a dummy factory-provided object).
	* It can be called multiple times to add options.
	* This calls virtual AddConvertArg() function.
	* @param optionlist List of options prepared by e.g. SplitString(), or just a single option (safestring). 
	*				The option names must be alphanumeric. Single names are taken as flags, a name=value syntax creates a value option.
	* @param opt Output parameter: here the recognized options are inserted.
	* @param throwhandler It is called in case of errors or unrecognized options. The default handler calls Warning() function and ignores the option.
	* @return True, if no problems were encountered. False, if throwhandler was called.
	*/
	bool ConvertArgs(const Nbaseutil::safestringlist& optionlist, ConvertOptions& opt, Nbaseutil::ThrowHandlerFunc throwhandler=LogWarnings()) const;

	/// Constant bit flags to be used in Flags() and SetFlags().
	enum MemBlockFlags {
		/// Object is not to be delete'd  when refcount drops to zero.
		mem_undeletable = 1<<2,
		/// Object is considered constant and may not be changed. This flag is managed by SetConst() and IsConst() member functions.
		mem_const = 1<<3,			
		/// The object has some sticky secondary data items which should not be released by MemBlockImpl::FlushSecondary(). This flag is managed automatically by SetSecondaryItem().
		mem_has_sticky_attrs = 1<<5, 
		/// An internal flag for some recursive algorithms
		mem_in_recursion = 1<<6,
		/// The MemBlock object was created by automatic conversion of a scalar into an 1-element vector
		mem_created_from_scalar = 1<<7,
		/// Changes to MemBlock object are logged via the logger facility in Debug build
		mem_dbgwatch = 1<<8,
	};

	/// Low-level function. Return MemBlock flags composed of enum MemBlockFlags constants.
	unsigned short Flags() const {return flags_;}

	/// Low-level function. Set the flags field. Return previous flags. Use only when you know what you are doing!
	unsigned short SetFlags(unsigned short f) {unsigned short prev=flags_; flags_ = f; return prev;}

	/// Low-level function. Return the reference count of this MemBlock object.
	int	RefCount() const {return refcount_;}

	/// Low-level function. Declare the object const or not. This is a dynamic property used mostly in Debug builds for checking proper module behaviour.
	void SetConst(bool bconst=true);

	/// Low-level function. Return the current constness value. This is called mostly from Debug build asserts. See SetConst().
	bool IsConst() const {return (flags_ & mem_const)!=0;}

	/// Low-level function. Checks that the remembered thread ID for this MemBlock is the same as for currently running thread. This works only in special build and is used for debugging asserts.
	void CheckThreadId(const Nbaseutil::safestring& name, bool zero_allowed=false) const;

	/// Return logical type of the object. This is a lg_* constant defined in the actual dynamic class of the object, or in some parent class.
	int GetLgType() const {return lg_type_;}

	/// Set object logical type. If the type is not supported or not suitable for the current object, an exception is thrown.
	void SetLgType(const Nbaseutil::safestring& lg_type);

	/// Get container of script-level additional attributes.
	PContainer GetAttr(bool sticky) const;

	/**
	* Traverse the object hierarchy in deep fashion; call visitor methods for each subobject and subvector and for "sticky" attributes.
	* 
	* For each distinct object in the hierarchy tree the following methods are called: 
	*   * TraverseBegin()
	*   * attribute and subobject recursion
	*   * TraverseEnd()
	*
	* If the object is of a polymorphic type, then TraverseBegin() and TraverseEnd() are called once for it. 
	* Attributes and subobjects are listed inbetween for every class in the derivation chain, beginning from the most base and ending by the most derived class.
	* If the object contains numeric or string vectors, then visitor's VisitVData() method is called in this step. 
	*/
	void Traverse(TraverseVisitor& visitor, const TraverseNode& node);

	/// Calculate the approximate memory usage taken up by this object, recursively with children and attributes. 
	Nbaseutil::uint64 CalcMemUsage() const;


	/// Auxiliary class for storing CalcMemUsage() state between calls.
	class DI_MemBlock CalcMemUsageState {
	public:
		CalcMemUsageState();
		~CalcMemUsageState();
	private:
		CalcMemUsageState(const CalcMemUsageState&);
		void operator=(const CalcMemUsageState&);
		friend class MemBlock;
		void* pimpl_;
	};

	/**
	* Calculate the approximate memory usage taken up by this object, recursively with children and attributes. The state object 
	* is used for avoding duplicate counting of shared objects when calling CalcMemUsage() multiple times, presumably on different objects.
	* @return The total amount of memory seen so far by using the passed state object.
	*/
	Nbaseutil::uint64 CalcMemUsage(CalcMemUsageState& state) const;

public: // virtual interface
	/**
	* @brief Returns the name of the actual class. 
	* Each derived class shall override this function. 
	* This feature in some sense duplicates the C++ typeid(...).name facility,
	* with the difference being that it is well-defined and portable.
	*
	* @return Pointer to the class name (a string literal).
	*/
	virtual const char* Class() const=0; 

	/**
	* @brief Check if it is safe to cast the object to another type. 
	*
	* This is a more flexible version of C++ dynamic_cast<> facility, in that
	* the checked class is not required to exist at compile time. Also pseudo-names are permitted.
	*
	* @return True if the object is of indicated class or of a class derived from that, or the object conforms to a pseudoclass like "stencil".
	* @param szClassName Name of the class as returned by Class() method, or a pseudoname like "stencil". Case insensitive.
	*/ 
	virtual bool Conforms(const char *szClassName) const=0;

	/// The constants to use with Entertain().
	enum entertainmode_t {
		/// Call visitor for itself and all children, in deep recursion.
        enter_deep,
		/// Call visitor for first level contained children only. 
		enter_first_level_children,
		/// Call visitor for itself only.
		enter_itself_only,
		/// For internal use with Traverse() function, do not use this value in client code!
		enter_traverse,
		/// Call visitor for all children recursively, but not for this object itself.
        enter_deep_children,
	};

	/**
	* Scans the MemBlock data structure beginning from this object.
	* Calls visitor.Visit() for contained MemBlock and DataItem objects.
	* The scanning is finished early if some visitor.Visit() returns MemBlockVisitor::stop_scan.
	* @param visitor An object of a class derived from MemBlockVisitor.
	* @param name Name of this object. If not applicable, an empty string is passed.
	* @param mode Operation mode constant of entertainmode_t type.
	* @return Return value is false, to terminate the scan early, if some called visitor.Visit() returns MemBlockVisitor::stop_scan.
	*/
	virtual bool Entertain(MemBlockVisitor& visitor, const Nbaseutil::safestring& name, entertainmode_t mode=enter_deep)=0;	

	enum iteratemode_t {
		iter_skip_memblock=(1<<0),
		iter_skip_sharable=(1<<1),
		iter_skip_scalar=(1<<2),
		iter_skip_transient=(1<<3),
	};

	/// Iterate transient and sticky attributes and all subobjects; call visitor.Visit() on each of them.
	virtual void IterateChildren(AcaVisitor& visitor, const TraverseNode& node)=0;
		
	/**
	* @brief Execute an extra command on the object.
	* This method is used for supporting extra functionality without adding new virtual functions.
	* Each derived class which overrides this method shall call the parent class for any unrecognized commands.
	* This facility is mostly for implementation, so it is not described here in more detail.
	*
	* @param pszCommand The command to execute. The recognized commands depend on the actual class of the object. 
	* @param iArg The number of additional parameters in the vArg array. The number of parameters depends on the verb.
	* @param vArg An array containing additional parameters. The meaning of parameters depends on the verb. If iArg==0, one can pass NULL as the vArg parameter.
	* @return Undefined value if the command is not supported, otherwise the value depending on the command.
	*/
	virtual SafeValue DoVerb(const char* pszCommand, int iArg, SafeValue vArg[]);

	/**
	* Check and insert a new conversion option. The base class implementation just stores the option in the opt object.
	* @param option Option name, trimmed.
	* @param value Option value. If no value was present, 1 is passed.
	* @param opt The settings object where a setting should be stored.
	* @param throwhandler ThrowHandler for reporting problems.
	* @return True, if the option was successfully processed. False, if there were problems, but throwhandler did not want to throw.
	*/
	virtual bool AddConvertArg(const Nbaseutil::safestring& option, const DataItem& value, ConvertOptions& opt, Nbaseutil::ThrowHandlerFunc throwhandler=LogWarnings()) const=0;

	/**
	* Convert the 'source' object into the type and representation of this class.
	* This method is called on the destination class type object (often a dummy factory-provided object).
	* Thus the state of *this object is not relevant and should not be studied.
	* Override in derived classes to support conversion from the same and other classes.
	* This function may not call ConvertTo() directly or indirectly.
	* This should be a "static virtual" function if C++ supported such beast.
	*
	* This function always produces an object of the same dynamic type than *this object.
	* This means that passing e.g. an Image to Vector::ConvertFrom() yields a Vector object (slicing occurs).
	* 
	* @return Converted object or NULL, if conversion not implemented.
	* @param source The input object to convert.
	* @param opt Additional conversion options.
	*/	
	virtual PMemBlock ConvertFrom(const PMemBlock source, const ConvertOptions& opt) const;

	/**
	* Convert this object to another class. 
	* This method is used as a fallback if other class' ConvertFrom() is not capable 
	* to convert directly from this class (for example, implemented in an independent DLL).
	* Override to perform conversions which are not implemented for destination type ConvertFrom().
	* This function may not call ConvertFrom() directly or indirectly.
	* @param classname The destination type classname.
	* @return The object converted to the destination class type, or NULL, if not implemented.
	*/
	virtual PMemBlock ConvertTo(const Nbaseutil::safestring& classname) const;

	/**
	* Process serialization options list in string format and add options to the formatter object. 
	* It can be called multiple times to add options.
	* @param optionlist List of options prepared by e.g. SplitString(), or just a single option (safestring). 
	*				The option names must be alphanumeric. Single names are taken as flags, a name=value syntax creates a value option.
	* @param formatter The options included in the optionlist are added to this object.
	* @param throwhandler It is called in case of errors. The default handler calls Warning() function and ignores the option.
	* @return True, if no problems were encountered. False, if throwhandler was called.
	*/
	virtual bool SerialArgs(const Nbaseutil::safestringlist& optionlist, Formatter& formatter, Nbaseutil::ThrowHandlerFunc throwhandler=LogWarnings()) const;

	/**
	* Check the state of this object (including parent class parts) and add error messages to msg.
	* This is called when consitency checks are turned on (default in Debug builds). See ConsistencyChecks() module description.
	* Override in derived classes to check the added data members. Call parent class Consistent() from inside.
	* @param msg Buffer for appending messages to. Terminate each message with a linefeed.
	* @param check_content If false, then do not check the data content values as these may be out of date or invalid. Only class invarints should be checked in this case.
	* @return False, if any problems found.
	*/
	virtual bool Consistent(Nbaseutil::safestring& msg, bool check_content=true) const=0;	
	
	/// Return the description of the MemBlock hiarchy class of dynamic type of the object. This should actually be a "static virtual" function.
	virtual const char* ClassDescription() const=0;

	/// Convert lg_type enum to the string representation; call parent class method if lg_type is unknown. The base class method returns an empty string for unknown types.
	virtual Nbaseutil::safestring LgType2String(int lg_type) const;

	/// Convert lg_type string to the enum representation; call parent class method if lg_type is unknown. The base class returns -1 if the type is unknown.
	virtual int String2LgType(const Nbaseutil::safestring& lg_type);

	/**
	* Perform binary operation between two operands (*this and y).
	* The operands remain unmodified.
	* All vector arithmetics operations are implemented by this interface.
	* The operands have to match each other and *this has to implement the needed opcode.
	* If these conditions are not fulfilled, an exception occurs.
	* @param opcode The operation to perform. Valid opcodes depend on the dynamic data types,
	*				see documentation of the op() function in derived classes (Vector::op(), IntervalVector::op()).
	* @param y The second operand. 
	* @param options Additional options for fine-tuning the operation.
	*/
	virtual PMemBlock op(char opcode, const PMemBlock y, const op_options& options) const;

protected: // interface for derived classes

	/// Return reference to the helper implementation class. The dynamic class of the type may vary according to the class and state of the MemBlock object. 
	MemBlockImpl& Pimpl() const;

protected: // virtual interface

	/// Enum values for use with the DoClone() virtual member function.
	enum copymode_t {
		/**
		* This is the same as copy_with_content, except that numeric arrays will not be copied; new potentially uninitialized numeric arrays are allocated instead.
		*/
		copy_no_content=0, 
		/**
		* Makes a full deep copy of the object; numeric arrays must be either copied or remain in shared use.
		* The actual numeric array duplication is delayed until calling non-const Pointer() method either on the original object or clone.
		* Thus it is encouraged to use const PMemBlock hierarchy pointers wherever possible, in order to reduce memory footprint.
		*/
		copy_with_content=1,
		/**
		* In container-like structures, make copy only of the upper layer, keep child items in shared use.
		*/
		copy_surface_only=2,
		/**
		* Make physical copy of the upper layer and all non-thread-safe extra data. 
		* MemBlock child items must remain in shared use, as they will be detached later explicitly 
		* by the DeepCopier class, which takes care of not duplicating the children unnecessarily.
		* Unline copy_surface_only, in this mode transient attributes should remain intact.
		*/
		copy_thread_pass_prepare=3,
		/**
		* Same as copy_surface_only for most classes. This is called for cloning the parent node in
		* a data tree before setting any child. If the class acts as a transparent proxy to a thread-shared 
		* common representation (e.g. VirtualImage) it will collapse itself into a non-thread-shared object
		* in this point as setting child values in a shared object would ruin the Acapella value semantics.
		*/
		copy_surface_only_for_setchild=4,
	};

	/// Helper function for copymode_t
	static bool IsCopyModeDeep(copymode_t copymode) {return copymode==copy_no_content || copymode==copy_with_content;}

	/// Helper function for copymode_t
	static bool IsCopyModeSurfaceOnly(copymode_t copymode) {return !IsCopyModeDeep(copymode);}

	/// Helper function for copymode_t
	static bool IsCopyModeIncludingTransient(copymode_t copymode) {return copymode==copy_thread_pass_prepare;}

	/** @brief Make a copy of the object. 
	* 
	* Each derived class shall override this method and return a new object of the same type. 
	* This method should make as cheap copy as possible. Data and contained objects should remain in shared use.
	* This is called by MemBlock::Clone() member function.
	* @param copy_mode Cloning mode, see copymode_t enumeration description.
	*/
	virtual PMemBlock DoClone(copymode_t copy_mode) const=0;	

	/** Create a suitable helper implementation class by the new operator and return it. 
	* This function has to be overridden if the class defines new secondary item keys.
	*/
	virtual MemBlockImpl* DoPimpl() const;

	// gain more DLL independence. See http://developer.kde.org/kde2arch/devel-binarycompatibility.html
	/**
	* Value compare to another item b of the same or derived dynamic type. 
	* Override in derived classes to value compare the class' own data members (deep value comparison).
	* The overridden function can assume that both objects are of the same type.
	* Call the parent class implementation of Equals() from the overridden function to compare parent class parts.
	*
	* This function is called from operator==().
	* @param b Another object to compare with. Precondition: dynamic type of b is the same as of *this, or of derived type.
	*/
	virtual bool Equals(const MemBlock& b) const; 

	/**
	* Set a subitem in the object. This is called from SetSubItem(). If setting subitemname is not supported, the parent class method is called in overridden methods.
	* @param subitemname Subitem name. This is a single name, not a "path name". MemBlock base class supports the following subitem names:
	*			- @sticky: sets the container of sticky user attributes.
	*			- @transient: sets the container of non-sticky user attributes.
	*			- @type: changes the logical type of the object, item must be a string accepted by String2LgType().
	* @param item Subitem value.
	* @param fullpathname Subitem name with full path, as passed to SetSubItem(). This contains subitemname in the middle or in the end.
	* @param throwhandler Throwhandler for managing errors appearing during the operation. The default throwhandler just throws exceptions.
	* @return False, if errors occured, but throwhandler did not want to throw.
	*/
	virtual bool DoSetSubItem(const Nbaseutil::safestring& subitemname, const SafeValue& item, const Nbaseutil::safestring& fullpathname, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed)=0;

	/// Implement the functionality of GetDescription() for each class. Should be overridden in every derived class.
	virtual Nbaseutil::safestring DoGetDescription() const=0;

	// 15.10.2003: ResolveSubItem made protected; use the nonvirtual GetSubItem() instead.
	// The GetSubItem() takes care of recursive parsing of subitems. ResolveSubItem may now assume that it is receiving simple names, no subkeys involved.
	/**
	* Get a subitem or key value in the object. This is called from GetSubItem().
	* @param subitemname Subitem name. This is a single name, not a "path name". 
	*		If subitemname is "*", then a comma-separated list of all genuine subobjects is returned. 
	*       If subitemname is "!", then a comma-separated list of all supported keys is returned.
	*       If subitemname is empty, then a joint list of all subobjects and keys is returned.
	*		In the last two cases "technical" keys are prepended by a percent sign (%). These should not be immediately visible to the user.
	* 
	* @param throwhandler Throwhandler for managing errors appearing during the operation. The default throwhandler just throws exceptions.
	* @return False, if errors occured, but throwhandler did not want to throw.
	*/
	virtual SafeValue ResolveSubItem(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed) const=0;	

	/// Set logical type. Reorganize the class data to be compatible with the new type and call the parent class method.
	virtual void DoSetLgType(int lg_type);

	virtual void DoSerialize(int ser_format, SerializeVisitor& visitor, const Nbaseutil::safestring& itemname, const Formatter& formatter, Nbaseutil::safestring& buffer) const {
		throw Nbaseutil::Exception(Nbaseutil::ERR_NOTIMPLEMENTED, Nbaseutil::Printf("Serialization format %d not supported for: %s")(ser_format)(GetDescription()));
	}

	virtual PMemBlock DoUnSerialize(int ser_format, const Formatter& formatter, const char* buffer, const char** p_buff_end) const {
		throw Nbaseutil::Exception(Nbaseutil::ERR_NOTIMPLEMENTED, Nbaseutil::Printf("Unserialization not supported by: %s")(GetDescription()));
	}

protected: // implementation
	/// Copy ctor. Neither pimpl nor flags are copied, refcount of course also not.
	MemBlock(const MemBlock& b); 

	/// The ctor is declared protected as it is accessed only by derived classes.
	MemBlock();

	/// The dtor is declared protected in order to prohibit creation in static or automatic storage. All MemBlock hierarchy objects are created dynamically.
	virtual ~MemBlock();

	/// Delete the PIMPL object. It will be recreated automatically when needed.
	void ResetPimpl();

	/// To be called from inside Entertain() overrides for visiting child objects. The child smartpointer may be reseated during the call.
	bool EntertainChild(PMemBlock& child, MemBlockVisitor& Visitor, const Nbaseutil::safestring& name, entertainmode_t mode);

private: // implementation

	/// Assignment is not implemented because of potential slicing problems. Use Clone() instead.
	MemBlock& operator=(const MemBlock& a);

	/// In Debug build, verifies object checksum hash to detect illegal midification and memory corruption. In Release build does nothing.
	void CheckSum(const Nbaseutil::safestring& name, Nbaseutil::ThrowHandlerFunc throwhandler=ThrowIndeed) const;
	bool HasThreadId(thread_id_t a, const TraverseNode& node, bool zero_allowed) const;
	friend class ThreadIdChecker;

	/// Reference counting mechanism. This is used by:
	friend struct NIMacro::PMemBlock;
	friend class NIMacro::DataItem;
	friend class ExprToken;
	
	/// Increase the refcount.
	void	Capture() const {
		refcount_++;
#ifdef _DEBUG
		MemTrackCapture(this);
#endif
	} 

	/// Decrease the refcount, delete the object if this drops to zero and mem_undeletable flag has not been set.
	int		Release() const;

	void MakeDeepPhysicalCopy();

private: // data
	mutable MemBlockImpl* pimpl_; // Pointor to the helper implementation class, or NULL.
	mutable int refcount_; // Reference registration counter. 
	unsigned short flags_;	// One or more MemBlockFlags enum constants.
	unsigned short lg_type_; /// Logical subclass of the object. This shall be one of lg_* enum constants defined in the actual class.
};

/// A generic function for adding DLL-level extension functionality  without breaking DLL binary compatibility.
DI_MemBlock DataItem MemBlock_DoVerb(const Nbaseutil::safestring& verb, DataItem arg1=Undefined, DataItem arg2=Undefined);

/// Return the list of currently registered MemBlock hierarchy classes.
DI_MemBlock Nbaseutil::safestring ListClasses(char Separator);

/// Return the description of specified class.
DI_MemBlock Nbaseutil::safestring ClassDescription(const Nbaseutil::safestring& class_name);


//#ifndef _MSC_VER
//	Nbaseutil::safestring dllerror1();
//	using Nbaseutil::DWORD;
//	using Nbaseutil::LPTSTR;
//#endif


inline DataTypeBase::DataType TypeOf(const triple dummy) {return DataTypeBase::Triple;}


/// A helper template for scanning over images and other 1-D data arrays:
/** Sample instantiation:
* @code
* inline void f(unsigned int x) { printf("%d ", x); }
* for_each_pixel( (unsigned char*)poImage->Pointer(), poImage->width*poImage->height, f);
* @endcode
*/
template<class PixelType, class Functor> inline
Functor for_each_pixel(PixelType* A, unsigned long Len, Functor Op) {
	PixelType *B = A + Len;
	for (; A != B; ++A)
		Op(*A);
	return (Op); 
}

// Extended version of for_each_pixel(), passing along also the element index.
template<class PixelType, class Functor> inline
Functor for_each_pixel_ex(PixelType* A, unsigned long Len, Functor Op) {
	for (unsigned long i=0; i<Len; ++i)
		Op(A[i], i);
	return (Op); 
}

/// A typedef used in the NIMacro::ClassInfo structure. Defines a function type for creating dummy objects of MemBlock hierarchy.
typedef PMemBlock (*MemBlockCreatorFunc)();

/// A structure needed for the ExportedClasses() function in Acapella module libraries.
struct ClassInfo {
	const char* pszClassName;
	MemBlockCreatorFunc pfCreator;
};

/**
A typedef for declaring the signature of the ExportedClasses() function in module libraries. The typedef is not used directly.
External DLL-s which inherit new MemBlock hierarchy classes, have to export a function 
 named "ExportedClasses" of the above type. Example:
@code
	extern "C" 
#ifdef _MSC_VER
	__declspec(dllexport)
#endif
	unsigned int ExportedClasses(const ClassInfo*& pClasses, int& iCount) {
		static ClassInfo[] p = {
			{"myclass", MyClassCreator},
			{"anotherclass", AnotherClassCreator}
		};
		pClasses = p;
		iCount = sizeof(p)/sizeof(ClassInfo);
		return 0;
  }
 @endcode 
 Class creator functions should create a minimal exemplar of the class and return the pointer:
@code
  MemBlock* MyClassCreator() { return new MyClass(); }
@endcode
Acapella engine will call the creator function for certain conversions and checks. The 
created object is not modified, only its virtual method interface is used.
*/
typedef unsigned int (*ExportedClassesFunc)(const ClassInfo*& pClasses, int& iCount);

/**
* A debugging support function, to be used in _DEBUG builds.
* Assigns specified thread ID to MemBlock m, in deep recursion. 
* DEBUG_PAUSE is called if current thread_id is existing, nonzero and wrong.
* @param thread_id The thread ID to assign. This should be Mutex::GetCurrentThreadId() for initializing an object received from another thread, or 0 for preparing the object for thread border passing.
*/
DI_MemBlock void AssignThreadId(PMemBlock &m, thread_id_t thread_id);

/**
* A debugging support function, to be used in _DEBUG builds.
* Checks that the memblock and its children have the exact specified thread_id. 
* DEBUG_PAUSE is called for wrong or missing thread id-s.
* @param thread_id The thread ID to check for. This should be Mutex::GetCurrentThreadId() for normal objects, or 0 for objects in the state of thread border passing.
* @return True, if there were no thread ID mismatches.
*/
DI_MemBlock bool HasThreadId(PMemBlock& m, thread_id_t thread_id);


////////////////////////// IMPLEMENTATION ///////////////////////////////


inline ItemType MemBlock::GetSubItemType(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler) const {
	try {
		return GetSubItem(subitemname, throwhandler).GetType();
	} catch(const Nbaseutil::Exception& e) {
		Throw(e, throwhandler);
		return Undefined;
	}
}

inline int MemBlock::GetSubItemInt(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler) const {
	try {
		return GetSubItem(subitemname, throwhandler).GetInt(throwhandler);
	} catch(const Nbaseutil::Exception& e) {
		Throw(e, throwhandler);
		return 0;
	}
}

inline double MemBlock::GetSubItemDouble(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler) const {
	try {
		return GetSubItem(subitemname, throwhandler).GetFloating(throwhandler);
	} catch(const Nbaseutil::Exception& e) {
		Throw(e, throwhandler);
		return 0;
	}
}

inline Nbaseutil::safestring MemBlock::GetSubItemString(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler) const {
	try {
		return GetSubItem(subitemname, throwhandler).GetString(throwhandler);
	} catch(const Nbaseutil::Exception& e) {
		Throw(e, throwhandler);
		return "";
	}
}

inline void* MemBlock::GetSubItemPointer(const Nbaseutil::safestring& subitemname, Nbaseutil::ThrowHandlerFunc throwhandler) const {
	try {
		return const_cast<void*>(GetSubItem(subitemname, throwhandler).GetPointer(throwhandler));
	} catch(const Nbaseutil::Exception& e) {
		Throw(e, throwhandler);
		return NULL;
	}
}

inline PMemBlock::PMemBlock(const MemBlock* x) {
	if (x) x->Capture();
	p = const_cast<MemBlock*> (x);
//	if (x && x->JustCreated()) { x->Release(); x->SetJustCreated(false); }
}

inline PMemBlock::PMemBlock(const PMemBlock& b) {
	if (b.p) b.p->Capture();
	p = b.p;
}

DI_MemBlock void PimplFlushSecondary(MemBlockImpl* impl);

inline void PMemBlock::MakeClone() {
	if (p && p->RefCount()>1) {
		*this = p->Clone();
	} else if (p) {
		// Bugfix 15.12.2003: Cloning is assumed to forget secondary data
		if (p->pimpl_) {
			PimplFlushSecondary(p->pimpl_);
		}
		// Bugfix end 15.12.2003
		// Bugfix 26.01.2004: reset constness flag
		p->SetConst(false);
		// Bugfix end 26.01.2004
	}
}

inline void PMemBlock::Assign(const MemBlock* x) const {
	if (x) {
		x->Capture();
	}
	if (p) { 
		MemBlock* q= p;
		p = NULL;	// Avoid infinite recursion in cyclic MemBlock structures.
		q->Release(); 
	}
	p = const_cast<MemBlock*> (x);
}

inline bool PMemBlock::Conforms(const char* ClassName) const {
	// Checks that the pointed MemBlock is not NULL and that it is of class ClassName or derived from that. This is the same as MemBlock::Conforms() except that in Debug builds one cannot call the latter easily on wrong type objects via arrow notation.
	if (!p) return false;
	if (p->Conforms(ClassName)) return true;
	return MakeBackwardCompatAutoConversionsToConform(ClassName);
}


template<class T>
	 inline		T& PMemBlock::As() {
	 T* q = dynamic_cast<T*>(p);
	 if (q) {
		 return *q;
	 } else {
		 throw Nbaseutil::Exception(Nbaseutil::ERR_BADDATA, Nbaseutil::Printf("This is not a %s: %s")(typeid(*q).name())(p? p->GetDescription(): "NULL"));
	 }
 }


//bool NumericNonNegativeInteger(const char *s); // self-explaining predicat
DI_MemBlock bool IsNaturalInteger(const char *s, const char extra='0'); // About the same, accepts also an extra character.

inline bool IsPracticallyZero(double f) {return std::abs(f)<1E-12;}

class SafeValue;

/**
* A base class for different kind of helper classes for managing different kind of options.
* This class manages two sets of options: flags and properties.
* A flag is a property with two possible values: true and false. 
* When querying the flag value through GetValue(), one gets back 1 or 0 respectively.
* In the opposite direction, when querying a value through GetFlag(), one gets false if value is 0, and 1 otherwise.
*/
class DI_MemBlock OptionsBase: public Nbaseutil::mb_malloced {
public: // typedefs

	/// @cond implementation_details
	typedef std::map<Nbaseutil::safestring, DataItem, std::less<Nbaseutil::safestring>, Nbaseutil::mb_allocator_typedef< std::map<Nbaseutil::safestring, DataItem>::value_type >::allocator > map_t;
	/// @endcond

	/**
	* A typedef for iterators iterating over the option map. The iterator points to a std::pair<safestring, DataItem>, 
	* the option name and value can thus be obtained by using the standard std::pair notation (iter->first and iter->second).
	* The iterators can be obtained by the begin() and end() member functions.
	*/
	typedef map_t::const_iterator const_iterator;

public:
	/// Set a boolean option value (flag).
	void SetFlag(const Nbaseutil::safestring& flagname, bool state=true);

	/// Get a boolean option value (flag). If missing, the defaultstate is returned. Values set by SetValue() return true if they are not integer 0.
	bool GetFlag(const Nbaseutil::safestring& flagname, bool defaultstate=false) const;

	/// Set a general option value. 
	void SetValue(const Nbaseutil::safestring& name, const DataItem& value);

	/// Get a general option value. If missing, the defaultvalue is returned. Flags by SetFlag() return 0 or 1 here.
	DataItem GetValue(const Nbaseutil::safestring& name, const DataItem& defaultvalue) const;

	/// Remove all flags and values.
	void Clear();

	/// Return the number of options.
	int Count() const {return int(vals_.size());}
	
	/// Return an iterator to the beginning of options sequence. The iterator will remain valid while this object is not modified.
	const_iterator begin() const {return vals_.begin();}

	/// Return an iterator past the end of options sequence. The iterator will remain valid while this object is not modified.
	const_iterator end() const {return vals_.end();}

private: // implementation
	map_t vals_;
};


class DI_MemBlock op_options: public OptionsBase {
	typedef OptionsBase super;
};

class DI_MemBlock ConvertOptions: public OptionsBase {
	typedef OptionsBase super;
};

#ifndef CALLBACK
#ifdef _MSC_VER
#define CALLBACK    __stdcall
#else
#define CALLBACK
#endif
#endif

/// This function should be called to restore the "stack guard page" after a stack overflow exception has occured. Does nothing in non-x86 builds.
DI_MemBlock void RestoreStackGuardPage();

//enum constants_memblock_h {
//#ifdef _DEBUG
//	SAFETY_MARGIN=0,
//#else
//	SAFETY_MARGIN=5,
//#endif
//};

// An iround() function for templates. On floating-point arguments it performs rounding, on integer types does nothing.
template<typename T> inline int iroundt(T x) { return int(x); }
// specialization for floating-point types:
template<> inline int iroundt(double x) { return (x>0.0) ? int(x+0.5) : int(x-0.5); }
template<> inline int iroundt(float x) { return (x>0.0) ? int(x+0.5) : int(x-0.5); }

DI_MemBlock void MemBlockDllCleanup(); // Deletes any dynamically allocated resources. Used for leak detection etc. DLL might not be usable after that.

} // namespace NIMacro

#ifdef _MSC_VER

namespace std {

	/// Specialization of numeric_limits<> for the triple type.
	template <>
	class numeric_limits<NIMacro::triple> : public _Num_int_base {
public:
	typedef NIMacro::triple _Ty;
	static _Ty (__cdecl min)() _THROW0()
		{return (0); }
	static _Ty (__cdecl max)() _THROW0()
		{return 256*256*256-1; }
	static _Ty __cdecl epsilon() _THROW0()
		{return (0); }
	static _Ty __cdecl round_error() _THROW0()
		{return (0); }
	static _Ty __cdecl denorm_min() _THROW0()
		{return (0); }
	static _Ty __cdecl infinity() _THROW0()
		{return (0); }
	static _Ty __cdecl quiet_NaN() _THROW0()
		{return (0); }
	static _Ty __cdecl signaling_NaN() _THROW0()
		{return (0); }
	_STCONS(bool, is_signed, false);
	_STCONS(bool, is_integer, true);
	_STCONS(int, digits, CHAR_BIT * sizeof (NIMacro::triple));
	_STCONS(int, digits10, (CHAR_BIT * sizeof (NIMacro::triple))
		* 301L / 1000);
	};
} // namespace std

#else

#ifndef _STCONS
#define _STCONS(ty, name, val)	enum {name = val}
#endif

namespace std {

	template <>
		struct numeric_limits<NIMacro::triple>: public std::__numeric_limits_base {
	typedef NIMacro::triple Ty;
	static Ty min()
		{return 0; }
	static Ty max()
		{return 256*256*256-1; }
	static Ty epsilon()
		{return (0); }
	static Ty round_error()
		{return (0); }
	static Ty denorm_min()
		{return (0); }
	static Ty infinity()
		{return (0); }
	static Ty quiet_NaN()
		{return (0); }
	static Ty signaling_NaN()
		{return (0); }
	// Bugfix 27.05.2005: it seems linux does not make the type integer by default.
	_STCONS(bool, is_integer, true);
	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, 8* sizeof (NIMacro::triple));
	_STCONS(int, digits10, (8 * sizeof (NIMacro::triple))
		* 301L / 1000);
	_STCONS(bool, has_quiet_NaN, false);
	};

} // namespace std
#endif

// Some chemistry for succesful initialization of DLL-s.
//typedef void (*imacro_initFunc)();
//DI_MemBlock int MemblockInited(imacro_initFunc p);

#endif
